<?php
/**
 * Copyright 2024 LINE Corporation
 *
 * LINE Corporation licenses this file to you under the Apache License,
 * version 2.0 (the "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */
/**
 * MessagingApiApi
 * PHP version 7.4
 *
 * @category Class
 * @package  LINE\Clients\MessagingApi
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * LINE Messaging API
 *
 * This document describes LINE Messaging API.
 *
 * The version of the OpenAPI document: 0.0.1
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.6.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace LINE\Clients\MessagingApi\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use LINE\Clients\MessagingApi\ApiException;
use LINE\Clients\MessagingApi\Configuration;
use LINE\Clients\MessagingApi\HeaderSelector;
use LINE\Clients\MessagingApi\ObjectSerializer;

/**
 * MessagingApiApi Class Doc Comment
 *
 * @category Class
 * @package  LINE\Clients\MessagingApi
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class MessagingApiApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'audienceMatch' => [
            'application/json',
        ],
        'broadcast' => [
            'application/json',
        ],
        'cancelDefaultRichMenu' => [
            'application/json',
        ],
        'createRichMenu' => [
            'application/json',
        ],
        'createRichMenuAlias' => [
            'application/json',
        ],
        'deleteRichMenu' => [
            'application/json',
        ],
        'deleteRichMenuAlias' => [
            'application/json',
        ],
        'getAdPhoneMessageStatistics' => [
            'application/json',
        ],
        'getAggregationUnitNameList' => [
            'application/json',
        ],
        'getAggregationUnitUsage' => [
            'application/json',
        ],
        'getBotInfo' => [
            'application/json',
        ],
        'getDefaultRichMenuId' => [
            'application/json',
        ],
        'getFollowers' => [
            'application/json',
        ],
        'getGroupMemberCount' => [
            'application/json',
        ],
        'getGroupMemberProfile' => [
            'application/json',
        ],
        'getGroupMembersIds' => [
            'application/json',
        ],
        'getGroupSummary' => [
            'application/json',
        ],
        'getMembershipList' => [
            'application/json',
        ],
        'getMembershipSubscription' => [
            'application/json',
        ],
        'getMessageQuota' => [
            'application/json',
        ],
        'getMessageQuotaConsumption' => [
            'application/json',
        ],
        'getNarrowcastProgress' => [
            'application/json',
        ],
        'getNumberOfSentBroadcastMessages' => [
            'application/json',
        ],
        'getNumberOfSentMulticastMessages' => [
            'application/json',
        ],
        'getNumberOfSentPushMessages' => [
            'application/json',
        ],
        'getNumberOfSentReplyMessages' => [
            'application/json',
        ],
        'getPNPMessageStatistics' => [
            'application/json',
        ],
        'getProfile' => [
            'application/json',
        ],
        'getRichMenu' => [
            'application/json',
        ],
        'getRichMenuAlias' => [
            'application/json',
        ],
        'getRichMenuAliasList' => [
            'application/json',
        ],
        'getRichMenuBatchProgress' => [
            'application/json',
        ],
        'getRichMenuIdOfUser' => [
            'application/json',
        ],
        'getRichMenuList' => [
            'application/json',
        ],
        'getRoomMemberCount' => [
            'application/json',
        ],
        'getRoomMemberProfile' => [
            'application/json',
        ],
        'getRoomMembersIds' => [
            'application/json',
        ],
        'getWebhookEndpoint' => [
            'application/json',
        ],
        'issueLinkToken' => [
            'application/json',
        ],
        'leaveGroup' => [
            'application/json',
        ],
        'leaveRoom' => [
            'application/json',
        ],
        'linkRichMenuIdToUser' => [
            'application/json',
        ],
        'linkRichMenuIdToUsers' => [
            'application/json',
        ],
        'markMessagesAsRead' => [
            'application/json',
        ],
        'multicast' => [
            'application/json',
        ],
        'narrowcast' => [
            'application/json',
        ],
        'pushMessage' => [
            'application/json',
        ],
        'pushMessagesByPhone' => [
            'application/json',
        ],
        'replyMessage' => [
            'application/json',
        ],
        'richMenuBatch' => [
            'application/json',
        ],
        'setDefaultRichMenu' => [
            'application/json',
        ],
        'setWebhookEndpoint' => [
            'application/json',
        ],
        'testWebhookEndpoint' => [
            'application/json',
        ],
        'unlinkRichMenuIdFromUser' => [
            'application/json',
        ],
        'unlinkRichMenuIdFromUsers' => [
            'application/json',
        ],
        'updateRichMenuAlias' => [
            'application/json',
        ],
        'validateBroadcast' => [
            'application/json',
        ],
        'validateMulticast' => [
            'application/json',
        ],
        'validateNarrowcast' => [
            'application/json',
        ],
        'validatePush' => [
            'application/json',
        ],
        'validateReply' => [
            'application/json',
        ],
        'validateRichMenuBatchRequest' => [
            'application/json',
        ],
        'validateRichMenuObject' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation audienceMatch
     *
     * @param  \LINE\Clients\MessagingApi\Model\AudienceMatchMessagesRequest $audienceMatchMessagesRequest audienceMatchMessagesRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['audienceMatch'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function audienceMatch($audienceMatchMessagesRequest, string $contentType = self::contentTypes['audienceMatch'][0])
    {
        $this->audienceMatchWithHttpInfo($audienceMatchMessagesRequest, $contentType);
    }

    /**
     * Operation audienceMatchWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\AudienceMatchMessagesRequest $audienceMatchMessagesRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['audienceMatch'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function audienceMatchWithHttpInfo($audienceMatchMessagesRequest, string $contentType = self::contentTypes['audienceMatch'][0])
    {
        $request = $this->audienceMatchRequest($audienceMatchMessagesRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation audienceMatchAsync
     *
     * @param  \LINE\Clients\MessagingApi\Model\AudienceMatchMessagesRequest $audienceMatchMessagesRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['audienceMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function audienceMatchAsync($audienceMatchMessagesRequest, string $contentType = self::contentTypes['audienceMatch'][0])
    {
        return $this->audienceMatchAsyncWithHttpInfo($audienceMatchMessagesRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation audienceMatchAsyncWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\AudienceMatchMessagesRequest $audienceMatchMessagesRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['audienceMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function audienceMatchAsyncWithHttpInfo($audienceMatchMessagesRequest, string $contentType = self::contentTypes['audienceMatch'][0])
    {
        $returnType = '';
        $request = $this->audienceMatchRequest($audienceMatchMessagesRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'audienceMatch'
     *
     * @param  \LINE\Clients\MessagingApi\Model\AudienceMatchMessagesRequest $audienceMatchMessagesRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['audienceMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function audienceMatchRequest($audienceMatchMessagesRequest, string $contentType = self::contentTypes['audienceMatch'][0])
    {

        // verify the required parameter 'audienceMatchMessagesRequest' is set
        if ($audienceMatchMessagesRequest === null || (is_array($audienceMatchMessagesRequest) && count($audienceMatchMessagesRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $audienceMatchMessagesRequest when calling audienceMatch'
            );
        }


        $resourcePath = '/bot/ad/multicast/phone';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($audienceMatchMessagesRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($audienceMatchMessagesRequest));
            } else {
                $httpBody = $audienceMatchMessagesRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation broadcast
     *
     * @param  \LINE\Clients\MessagingApi\Model\BroadcastRequest $broadcastRequest broadcastRequest (required)
     * @param  string $xLineRetryKey Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['broadcast'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\LINE\Clients\MessagingApi\Model\ErrorResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse
     */
    public function broadcast($broadcastRequest, $xLineRetryKey = null, string $contentType = self::contentTypes['broadcast'][0])
    {
        list($response) = $this->broadcastWithHttpInfo($broadcastRequest, $xLineRetryKey, $contentType);
        return $response;
    }

    /**
     * Operation broadcastWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\BroadcastRequest $broadcastRequest (required)
     * @param  string $xLineRetryKey Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['broadcast'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\LINE\Clients\MessagingApi\Model\ErrorResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function broadcastWithHttpInfo($broadcastRequest, $xLineRetryKey = null, string $contentType = self::contentTypes['broadcast'][0])
    {
        $request = $this->broadcastRequest($broadcastRequest, $xLineRetryKey, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation broadcastAsync
     *
     * @param  \LINE\Clients\MessagingApi\Model\BroadcastRequest $broadcastRequest (required)
     * @param  string $xLineRetryKey Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['broadcast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function broadcastAsync($broadcastRequest, $xLineRetryKey = null, string $contentType = self::contentTypes['broadcast'][0])
    {
        return $this->broadcastAsyncWithHttpInfo($broadcastRequest, $xLineRetryKey, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation broadcastAsyncWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\BroadcastRequest $broadcastRequest (required)
     * @param  string $xLineRetryKey Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['broadcast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function broadcastAsyncWithHttpInfo($broadcastRequest, $xLineRetryKey = null, string $contentType = self::contentTypes['broadcast'][0])
    {
        $returnType = 'object';
        $request = $this->broadcastRequest($broadcastRequest, $xLineRetryKey, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'broadcast'
     *
     * @param  \LINE\Clients\MessagingApi\Model\BroadcastRequest $broadcastRequest (required)
     * @param  string $xLineRetryKey Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['broadcast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function broadcastRequest($broadcastRequest, $xLineRetryKey = null, string $contentType = self::contentTypes['broadcast'][0])
    {

        // verify the required parameter 'broadcastRequest' is set
        if ($broadcastRequest === null || (is_array($broadcastRequest) && count($broadcastRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $broadcastRequest when calling broadcast'
            );
        }



        $resourcePath = '/v2/bot/message/broadcast';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($xLineRetryKey !== null) {
            $headerParams['X-Line-Retry-Key'] = ObjectSerializer::toHeaderValue($xLineRetryKey);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($broadcastRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($broadcastRequest));
            } else {
                $httpBody = $broadcastRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelDefaultRichMenu
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelDefaultRichMenu'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cancelDefaultRichMenu(string $contentType = self::contentTypes['cancelDefaultRichMenu'][0])
    {
        $this->cancelDefaultRichMenuWithHttpInfo($contentType);
    }

    /**
     * Operation cancelDefaultRichMenuWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelDefaultRichMenu'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelDefaultRichMenuWithHttpInfo(string $contentType = self::contentTypes['cancelDefaultRichMenu'][0])
    {
        $request = $this->cancelDefaultRichMenuRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cancelDefaultRichMenuAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelDefaultRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelDefaultRichMenuAsync(string $contentType = self::contentTypes['cancelDefaultRichMenu'][0])
    {
        return $this->cancelDefaultRichMenuAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelDefaultRichMenuAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelDefaultRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelDefaultRichMenuAsyncWithHttpInfo(string $contentType = self::contentTypes['cancelDefaultRichMenu'][0])
    {
        $returnType = '';
        $request = $this->cancelDefaultRichMenuRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelDefaultRichMenu'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelDefaultRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cancelDefaultRichMenuRequest(string $contentType = self::contentTypes['cancelDefaultRichMenu'][0])
    {


        $resourcePath = '/v2/bot/user/all/richmenu';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createRichMenu
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuRequest $richMenuRequest richMenuRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRichMenu'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\RichMenuIdResponse
     */
    public function createRichMenu($richMenuRequest, string $contentType = self::contentTypes['createRichMenu'][0])
    {
        list($response) = $this->createRichMenuWithHttpInfo($richMenuRequest, $contentType);
        return $response;
    }

    /**
     * Operation createRichMenuWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuRequest $richMenuRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRichMenu'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\RichMenuIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRichMenuWithHttpInfo($richMenuRequest, string $contentType = self::contentTypes['createRichMenu'][0])
    {
        $request = $this->createRichMenuRequest($richMenuRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\RichMenuIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\RichMenuIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\RichMenuIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\RichMenuIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\RichMenuIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createRichMenuAsync
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuRequest $richMenuRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRichMenuAsync($richMenuRequest, string $contentType = self::contentTypes['createRichMenu'][0])
    {
        return $this->createRichMenuAsyncWithHttpInfo($richMenuRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRichMenuAsyncWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuRequest $richMenuRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRichMenuAsyncWithHttpInfo($richMenuRequest, string $contentType = self::contentTypes['createRichMenu'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\RichMenuIdResponse';
        $request = $this->createRichMenuRequest($richMenuRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createRichMenu'
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuRequest $richMenuRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createRichMenuRequest($richMenuRequest, string $contentType = self::contentTypes['createRichMenu'][0])
    {

        // verify the required parameter 'richMenuRequest' is set
        if ($richMenuRequest === null || (is_array($richMenuRequest) && count($richMenuRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $richMenuRequest when calling createRichMenu'
            );
        }


        $resourcePath = '/v2/bot/richmenu';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($richMenuRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($richMenuRequest));
            } else {
                $httpBody = $richMenuRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createRichMenuAlias
     *
     * @param  \LINE\Clients\MessagingApi\Model\CreateRichMenuAliasRequest $createRichMenuAliasRequest createRichMenuAliasRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createRichMenuAlias($createRichMenuAliasRequest, string $contentType = self::contentTypes['createRichMenuAlias'][0])
    {
        $this->createRichMenuAliasWithHttpInfo($createRichMenuAliasRequest, $contentType);
    }

    /**
     * Operation createRichMenuAliasWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\CreateRichMenuAliasRequest $createRichMenuAliasRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRichMenuAliasWithHttpInfo($createRichMenuAliasRequest, string $contentType = self::contentTypes['createRichMenuAlias'][0])
    {
        $request = $this->createRichMenuAliasRequest($createRichMenuAliasRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createRichMenuAliasAsync
     *
     * @param  \LINE\Clients\MessagingApi\Model\CreateRichMenuAliasRequest $createRichMenuAliasRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRichMenuAliasAsync($createRichMenuAliasRequest, string $contentType = self::contentTypes['createRichMenuAlias'][0])
    {
        return $this->createRichMenuAliasAsyncWithHttpInfo($createRichMenuAliasRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRichMenuAliasAsyncWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\CreateRichMenuAliasRequest $createRichMenuAliasRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRichMenuAliasAsyncWithHttpInfo($createRichMenuAliasRequest, string $contentType = self::contentTypes['createRichMenuAlias'][0])
    {
        $returnType = '';
        $request = $this->createRichMenuAliasRequest($createRichMenuAliasRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createRichMenuAlias'
     *
     * @param  \LINE\Clients\MessagingApi\Model\CreateRichMenuAliasRequest $createRichMenuAliasRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createRichMenuAliasRequest($createRichMenuAliasRequest, string $contentType = self::contentTypes['createRichMenuAlias'][0])
    {

        // verify the required parameter 'createRichMenuAliasRequest' is set
        if ($createRichMenuAliasRequest === null || (is_array($createRichMenuAliasRequest) && count($createRichMenuAliasRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createRichMenuAliasRequest when calling createRichMenuAlias'
            );
        }


        $resourcePath = '/v2/bot/richmenu/alias';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createRichMenuAliasRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createRichMenuAliasRequest));
            } else {
                $httpBody = $createRichMenuAliasRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRichMenu
     *
     * @param  string $richMenuId ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRichMenu'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteRichMenu($richMenuId, string $contentType = self::contentTypes['deleteRichMenu'][0])
    {
        $this->deleteRichMenuWithHttpInfo($richMenuId, $contentType);
    }

    /**
     * Operation deleteRichMenuWithHttpInfo
     *
     * @param  string $richMenuId ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRichMenu'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRichMenuWithHttpInfo($richMenuId, string $contentType = self::contentTypes['deleteRichMenu'][0])
    {
        $request = $this->deleteRichMenuRequest($richMenuId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteRichMenuAsync
     *
     * @param  string $richMenuId ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRichMenuAsync($richMenuId, string $contentType = self::contentTypes['deleteRichMenu'][0])
    {
        return $this->deleteRichMenuAsyncWithHttpInfo($richMenuId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRichMenuAsyncWithHttpInfo
     *
     * @param  string $richMenuId ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRichMenuAsyncWithHttpInfo($richMenuId, string $contentType = self::contentTypes['deleteRichMenu'][0])
    {
        $returnType = '';
        $request = $this->deleteRichMenuRequest($richMenuId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRichMenu'
     *
     * @param  string $richMenuId ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteRichMenuRequest($richMenuId, string $contentType = self::contentTypes['deleteRichMenu'][0])
    {

        // verify the required parameter 'richMenuId' is set
        if ($richMenuId === null || (is_array($richMenuId) && count($richMenuId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $richMenuId when calling deleteRichMenu'
            );
        }


        $resourcePath = '/v2/bot/richmenu/{richMenuId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($richMenuId !== null) {
            $resourcePath = str_replace(
                '{' . 'richMenuId' . '}',
                ObjectSerializer::toPathValue($richMenuId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRichMenuAlias
     *
     * @param  string $richMenuAliasId Rich menu alias ID that you want to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteRichMenuAlias($richMenuAliasId, string $contentType = self::contentTypes['deleteRichMenuAlias'][0])
    {
        $this->deleteRichMenuAliasWithHttpInfo($richMenuAliasId, $contentType);
    }

    /**
     * Operation deleteRichMenuAliasWithHttpInfo
     *
     * @param  string $richMenuAliasId Rich menu alias ID that you want to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRichMenuAliasWithHttpInfo($richMenuAliasId, string $contentType = self::contentTypes['deleteRichMenuAlias'][0])
    {
        $request = $this->deleteRichMenuAliasRequest($richMenuAliasId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteRichMenuAliasAsync
     *
     * @param  string $richMenuAliasId Rich menu alias ID that you want to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRichMenuAliasAsync($richMenuAliasId, string $contentType = self::contentTypes['deleteRichMenuAlias'][0])
    {
        return $this->deleteRichMenuAliasAsyncWithHttpInfo($richMenuAliasId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRichMenuAliasAsyncWithHttpInfo
     *
     * @param  string $richMenuAliasId Rich menu alias ID that you want to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRichMenuAliasAsyncWithHttpInfo($richMenuAliasId, string $contentType = self::contentTypes['deleteRichMenuAlias'][0])
    {
        $returnType = '';
        $request = $this->deleteRichMenuAliasRequest($richMenuAliasId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRichMenuAlias'
     *
     * @param  string $richMenuAliasId Rich menu alias ID that you want to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteRichMenuAliasRequest($richMenuAliasId, string $contentType = self::contentTypes['deleteRichMenuAlias'][0])
    {

        // verify the required parameter 'richMenuAliasId' is set
        if ($richMenuAliasId === null || (is_array($richMenuAliasId) && count($richMenuAliasId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $richMenuAliasId when calling deleteRichMenuAlias'
            );
        }


        $resourcePath = '/v2/bot/richmenu/alias/{richMenuAliasId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($richMenuAliasId !== null) {
            $resourcePath = str_replace(
                '{' . 'richMenuAliasId' . '}',
                ObjectSerializer::toPathValue($richMenuAliasId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAdPhoneMessageStatistics
     *
     * @param  string $date Date the message was sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20190831&#x60;) Time Zone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAdPhoneMessageStatistics'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse
     */
    public function getAdPhoneMessageStatistics($date, string $contentType = self::contentTypes['getAdPhoneMessageStatistics'][0])
    {
        list($response) = $this->getAdPhoneMessageStatisticsWithHttpInfo($date, $contentType);
        return $response;
    }

    /**
     * Operation getAdPhoneMessageStatisticsWithHttpInfo
     *
     * @param  string $date Date the message was sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20190831&#x60;) Time Zone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAdPhoneMessageStatistics'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAdPhoneMessageStatisticsWithHttpInfo($date, string $contentType = self::contentTypes['getAdPhoneMessageStatistics'][0])
    {
        $request = $this->getAdPhoneMessageStatisticsRequest($date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAdPhoneMessageStatisticsAsync
     *
     * @param  string $date Date the message was sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20190831&#x60;) Time Zone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAdPhoneMessageStatistics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdPhoneMessageStatisticsAsync($date, string $contentType = self::contentTypes['getAdPhoneMessageStatistics'][0])
    {
        return $this->getAdPhoneMessageStatisticsAsyncWithHttpInfo($date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAdPhoneMessageStatisticsAsyncWithHttpInfo
     *
     * @param  string $date Date the message was sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20190831&#x60;) Time Zone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAdPhoneMessageStatistics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdPhoneMessageStatisticsAsyncWithHttpInfo($date, string $contentType = self::contentTypes['getAdPhoneMessageStatistics'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse';
        $request = $this->getAdPhoneMessageStatisticsRequest($date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAdPhoneMessageStatistics'
     *
     * @param  string $date Date the message was sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20190831&#x60;) Time Zone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAdPhoneMessageStatistics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAdPhoneMessageStatisticsRequest($date, string $contentType = self::contentTypes['getAdPhoneMessageStatistics'][0])
    {

        // verify the required parameter 'date' is set
        if ($date === null || (is_array($date) && count($date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $date when calling getAdPhoneMessageStatistics'
            );
        }


        $resourcePath = '/v2/bot/message/delivery/ad_phone';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date,
            'date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAggregationUnitNameList
     *
     * @param  string $limit The maximum number of aggregation units you can get per request. (optional)
     * @param  string $start Value of the continuation token found in the next property of the JSON object returned in the response. If you can&#39;t get all the aggregation units in one request, include this parameter to get the remaining array. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAggregationUnitNameList'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\GetAggregationUnitNameListResponse
     */
    public function getAggregationUnitNameList($limit = null, $start = null, string $contentType = self::contentTypes['getAggregationUnitNameList'][0])
    {
        list($response) = $this->getAggregationUnitNameListWithHttpInfo($limit, $start, $contentType);
        return $response;
    }

    /**
     * Operation getAggregationUnitNameListWithHttpInfo
     *
     * @param  string $limit The maximum number of aggregation units you can get per request. (optional)
     * @param  string $start Value of the continuation token found in the next property of the JSON object returned in the response. If you can&#39;t get all the aggregation units in one request, include this parameter to get the remaining array. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAggregationUnitNameList'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\GetAggregationUnitNameListResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAggregationUnitNameListWithHttpInfo($limit = null, $start = null, string $contentType = self::contentTypes['getAggregationUnitNameList'][0])
    {
        $request = $this->getAggregationUnitNameListRequest($limit, $start, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\GetAggregationUnitNameListResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\GetAggregationUnitNameListResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\GetAggregationUnitNameListResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\GetAggregationUnitNameListResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\GetAggregationUnitNameListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAggregationUnitNameListAsync
     *
     * @param  string $limit The maximum number of aggregation units you can get per request. (optional)
     * @param  string $start Value of the continuation token found in the next property of the JSON object returned in the response. If you can&#39;t get all the aggregation units in one request, include this parameter to get the remaining array. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAggregationUnitNameList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAggregationUnitNameListAsync($limit = null, $start = null, string $contentType = self::contentTypes['getAggregationUnitNameList'][0])
    {
        return $this->getAggregationUnitNameListAsyncWithHttpInfo($limit, $start, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAggregationUnitNameListAsyncWithHttpInfo
     *
     * @param  string $limit The maximum number of aggregation units you can get per request. (optional)
     * @param  string $start Value of the continuation token found in the next property of the JSON object returned in the response. If you can&#39;t get all the aggregation units in one request, include this parameter to get the remaining array. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAggregationUnitNameList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAggregationUnitNameListAsyncWithHttpInfo($limit = null, $start = null, string $contentType = self::contentTypes['getAggregationUnitNameList'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\GetAggregationUnitNameListResponse';
        $request = $this->getAggregationUnitNameListRequest($limit, $start, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAggregationUnitNameList'
     *
     * @param  string $limit The maximum number of aggregation units you can get per request. (optional)
     * @param  string $start Value of the continuation token found in the next property of the JSON object returned in the response. If you can&#39;t get all the aggregation units in one request, include this parameter to get the remaining array. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAggregationUnitNameList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAggregationUnitNameListRequest($limit = null, $start = null, string $contentType = self::contentTypes['getAggregationUnitNameList'][0])
    {




        $resourcePath = '/v2/bot/message/aggregation/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAggregationUnitUsage
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAggregationUnitUsage'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\GetAggregationUnitUsageResponse
     */
    public function getAggregationUnitUsage(string $contentType = self::contentTypes['getAggregationUnitUsage'][0])
    {
        list($response) = $this->getAggregationUnitUsageWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getAggregationUnitUsageWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAggregationUnitUsage'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\GetAggregationUnitUsageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAggregationUnitUsageWithHttpInfo(string $contentType = self::contentTypes['getAggregationUnitUsage'][0])
    {
        $request = $this->getAggregationUnitUsageRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\GetAggregationUnitUsageResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\GetAggregationUnitUsageResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\GetAggregationUnitUsageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\GetAggregationUnitUsageResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\GetAggregationUnitUsageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAggregationUnitUsageAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAggregationUnitUsage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAggregationUnitUsageAsync(string $contentType = self::contentTypes['getAggregationUnitUsage'][0])
    {
        return $this->getAggregationUnitUsageAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAggregationUnitUsageAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAggregationUnitUsage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAggregationUnitUsageAsyncWithHttpInfo(string $contentType = self::contentTypes['getAggregationUnitUsage'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\GetAggregationUnitUsageResponse';
        $request = $this->getAggregationUnitUsageRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAggregationUnitUsage'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAggregationUnitUsage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAggregationUnitUsageRequest(string $contentType = self::contentTypes['getAggregationUnitUsage'][0])
    {


        $resourcePath = '/v2/bot/message/aggregation/info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBotInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBotInfo'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\BotInfoResponse
     */
    public function getBotInfo(string $contentType = self::contentTypes['getBotInfo'][0])
    {
        list($response) = $this->getBotInfoWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getBotInfoWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBotInfo'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\BotInfoResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBotInfoWithHttpInfo(string $contentType = self::contentTypes['getBotInfo'][0])
    {
        $request = $this->getBotInfoRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\BotInfoResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\BotInfoResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\BotInfoResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\BotInfoResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\BotInfoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBotInfoAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBotInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBotInfoAsync(string $contentType = self::contentTypes['getBotInfo'][0])
    {
        return $this->getBotInfoAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBotInfoAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBotInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBotInfoAsyncWithHttpInfo(string $contentType = self::contentTypes['getBotInfo'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\BotInfoResponse';
        $request = $this->getBotInfoRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBotInfo'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBotInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBotInfoRequest(string $contentType = self::contentTypes['getBotInfo'][0])
    {


        $resourcePath = '/v2/bot/info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDefaultRichMenuId
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDefaultRichMenuId'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\RichMenuIdResponse
     */
    public function getDefaultRichMenuId(string $contentType = self::contentTypes['getDefaultRichMenuId'][0])
    {
        list($response) = $this->getDefaultRichMenuIdWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getDefaultRichMenuIdWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDefaultRichMenuId'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\RichMenuIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDefaultRichMenuIdWithHttpInfo(string $contentType = self::contentTypes['getDefaultRichMenuId'][0])
    {
        $request = $this->getDefaultRichMenuIdRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\RichMenuIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\RichMenuIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\RichMenuIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\RichMenuIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\RichMenuIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDefaultRichMenuIdAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDefaultRichMenuId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDefaultRichMenuIdAsync(string $contentType = self::contentTypes['getDefaultRichMenuId'][0])
    {
        return $this->getDefaultRichMenuIdAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDefaultRichMenuIdAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDefaultRichMenuId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDefaultRichMenuIdAsyncWithHttpInfo(string $contentType = self::contentTypes['getDefaultRichMenuId'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\RichMenuIdResponse';
        $request = $this->getDefaultRichMenuIdRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDefaultRichMenuId'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDefaultRichMenuId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDefaultRichMenuIdRequest(string $contentType = self::contentTypes['getDefaultRichMenuId'][0])
    {


        $resourcePath = '/v2/bot/user/all/richmenu';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFollowers
     *
     * @param  string $start Value of the continuation token found in the next property of the JSON object returned in the response. Include this parameter to get the next array of user IDs. (optional)
     * @param  int $limit The maximum number of user IDs to retrieve in a single request. (optional, default to 300)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFollowers'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\GetFollowersResponse
     */
    public function getFollowers($start = null, $limit = 300, string $contentType = self::contentTypes['getFollowers'][0])
    {
        list($response) = $this->getFollowersWithHttpInfo($start, $limit, $contentType);
        return $response;
    }

    /**
     * Operation getFollowersWithHttpInfo
     *
     * @param  string $start Value of the continuation token found in the next property of the JSON object returned in the response. Include this parameter to get the next array of user IDs. (optional)
     * @param  int $limit The maximum number of user IDs to retrieve in a single request. (optional, default to 300)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFollowers'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\GetFollowersResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFollowersWithHttpInfo($start = null, $limit = 300, string $contentType = self::contentTypes['getFollowers'][0])
    {
        $request = $this->getFollowersRequest($start, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\GetFollowersResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\GetFollowersResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\GetFollowersResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\GetFollowersResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\GetFollowersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFollowersAsync
     *
     * @param  string $start Value of the continuation token found in the next property of the JSON object returned in the response. Include this parameter to get the next array of user IDs. (optional)
     * @param  int $limit The maximum number of user IDs to retrieve in a single request. (optional, default to 300)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFollowers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFollowersAsync($start = null, $limit = 300, string $contentType = self::contentTypes['getFollowers'][0])
    {
        return $this->getFollowersAsyncWithHttpInfo($start, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFollowersAsyncWithHttpInfo
     *
     * @param  string $start Value of the continuation token found in the next property of the JSON object returned in the response. Include this parameter to get the next array of user IDs. (optional)
     * @param  int $limit The maximum number of user IDs to retrieve in a single request. (optional, default to 300)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFollowers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFollowersAsyncWithHttpInfo($start = null, $limit = 300, string $contentType = self::contentTypes['getFollowers'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\GetFollowersResponse';
        $request = $this->getFollowersRequest($start, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFollowers'
     *
     * @param  string $start Value of the continuation token found in the next property of the JSON object returned in the response. Include this parameter to get the next array of user IDs. (optional)
     * @param  int $limit The maximum number of user IDs to retrieve in a single request. (optional, default to 300)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFollowers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFollowersRequest($start = null, $limit = 300, string $contentType = self::contentTypes['getFollowers'][0])
    {


        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling MessagingApiApi.getFollowers, must be smaller than or equal to 1000.');
        }
        

        $resourcePath = '/v2/bot/followers/ids';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGroupMemberCount
     *
     * @param  string $groupId Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMemberCount'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\GroupMemberCountResponse
     */
    public function getGroupMemberCount($groupId, string $contentType = self::contentTypes['getGroupMemberCount'][0])
    {
        list($response) = $this->getGroupMemberCountWithHttpInfo($groupId, $contentType);
        return $response;
    }

    /**
     * Operation getGroupMemberCountWithHttpInfo
     *
     * @param  string $groupId Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMemberCount'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\GroupMemberCountResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGroupMemberCountWithHttpInfo($groupId, string $contentType = self::contentTypes['getGroupMemberCount'][0])
    {
        $request = $this->getGroupMemberCountRequest($groupId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\GroupMemberCountResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\GroupMemberCountResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\GroupMemberCountResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\GroupMemberCountResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\GroupMemberCountResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGroupMemberCountAsync
     *
     * @param  string $groupId Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMemberCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupMemberCountAsync($groupId, string $contentType = self::contentTypes['getGroupMemberCount'][0])
    {
        return $this->getGroupMemberCountAsyncWithHttpInfo($groupId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGroupMemberCountAsyncWithHttpInfo
     *
     * @param  string $groupId Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMemberCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupMemberCountAsyncWithHttpInfo($groupId, string $contentType = self::contentTypes['getGroupMemberCount'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\GroupMemberCountResponse';
        $request = $this->getGroupMemberCountRequest($groupId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGroupMemberCount'
     *
     * @param  string $groupId Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMemberCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGroupMemberCountRequest($groupId, string $contentType = self::contentTypes['getGroupMemberCount'][0])
    {

        // verify the required parameter 'groupId' is set
        if ($groupId === null || (is_array($groupId) && count($groupId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $groupId when calling getGroupMemberCount'
            );
        }


        $resourcePath = '/v2/bot/group/{groupId}/members/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($groupId !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($groupId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGroupMemberProfile
     *
     * @param  string $groupId Group ID (required)
     * @param  string $userId User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMemberProfile'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\GroupUserProfileResponse
     */
    public function getGroupMemberProfile($groupId, $userId, string $contentType = self::contentTypes['getGroupMemberProfile'][0])
    {
        list($response) = $this->getGroupMemberProfileWithHttpInfo($groupId, $userId, $contentType);
        return $response;
    }

    /**
     * Operation getGroupMemberProfileWithHttpInfo
     *
     * @param  string $groupId Group ID (required)
     * @param  string $userId User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMemberProfile'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\GroupUserProfileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGroupMemberProfileWithHttpInfo($groupId, $userId, string $contentType = self::contentTypes['getGroupMemberProfile'][0])
    {
        $request = $this->getGroupMemberProfileRequest($groupId, $userId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\GroupUserProfileResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\GroupUserProfileResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\GroupUserProfileResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\GroupUserProfileResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\GroupUserProfileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGroupMemberProfileAsync
     *
     * @param  string $groupId Group ID (required)
     * @param  string $userId User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMemberProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupMemberProfileAsync($groupId, $userId, string $contentType = self::contentTypes['getGroupMemberProfile'][0])
    {
        return $this->getGroupMemberProfileAsyncWithHttpInfo($groupId, $userId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGroupMemberProfileAsyncWithHttpInfo
     *
     * @param  string $groupId Group ID (required)
     * @param  string $userId User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMemberProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupMemberProfileAsyncWithHttpInfo($groupId, $userId, string $contentType = self::contentTypes['getGroupMemberProfile'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\GroupUserProfileResponse';
        $request = $this->getGroupMemberProfileRequest($groupId, $userId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGroupMemberProfile'
     *
     * @param  string $groupId Group ID (required)
     * @param  string $userId User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMemberProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGroupMemberProfileRequest($groupId, $userId, string $contentType = self::contentTypes['getGroupMemberProfile'][0])
    {

        // verify the required parameter 'groupId' is set
        if ($groupId === null || (is_array($groupId) && count($groupId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $groupId when calling getGroupMemberProfile'
            );
        }

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling getGroupMemberProfile'
            );
        }


        $resourcePath = '/v2/bot/group/{groupId}/member/{userId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($groupId !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($groupId),
                $resourcePath
            );
        }
        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGroupMembersIds
     *
     * @param  string $groupId Group ID (required)
     * @param  string $start Value of the continuation token found in the &#x60;next&#x60; property of the JSON object returned in the response. Include this parameter to get the next array of user IDs for the members of the group. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMembersIds'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\MembersIdsResponse
     */
    public function getGroupMembersIds($groupId, $start = null, string $contentType = self::contentTypes['getGroupMembersIds'][0])
    {
        list($response) = $this->getGroupMembersIdsWithHttpInfo($groupId, $start, $contentType);
        return $response;
    }

    /**
     * Operation getGroupMembersIdsWithHttpInfo
     *
     * @param  string $groupId Group ID (required)
     * @param  string $start Value of the continuation token found in the &#x60;next&#x60; property of the JSON object returned in the response. Include this parameter to get the next array of user IDs for the members of the group. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMembersIds'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\MembersIdsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGroupMembersIdsWithHttpInfo($groupId, $start = null, string $contentType = self::contentTypes['getGroupMembersIds'][0])
    {
        $request = $this->getGroupMembersIdsRequest($groupId, $start, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\MembersIdsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\MembersIdsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\MembersIdsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\MembersIdsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\MembersIdsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGroupMembersIdsAsync
     *
     * @param  string $groupId Group ID (required)
     * @param  string $start Value of the continuation token found in the &#x60;next&#x60; property of the JSON object returned in the response. Include this parameter to get the next array of user IDs for the members of the group. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMembersIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupMembersIdsAsync($groupId, $start = null, string $contentType = self::contentTypes['getGroupMembersIds'][0])
    {
        return $this->getGroupMembersIdsAsyncWithHttpInfo($groupId, $start, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGroupMembersIdsAsyncWithHttpInfo
     *
     * @param  string $groupId Group ID (required)
     * @param  string $start Value of the continuation token found in the &#x60;next&#x60; property of the JSON object returned in the response. Include this parameter to get the next array of user IDs for the members of the group. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMembersIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupMembersIdsAsyncWithHttpInfo($groupId, $start = null, string $contentType = self::contentTypes['getGroupMembersIds'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\MembersIdsResponse';
        $request = $this->getGroupMembersIdsRequest($groupId, $start, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGroupMembersIds'
     *
     * @param  string $groupId Group ID (required)
     * @param  string $start Value of the continuation token found in the &#x60;next&#x60; property of the JSON object returned in the response. Include this parameter to get the next array of user IDs for the members of the group. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMembersIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGroupMembersIdsRequest($groupId, $start = null, string $contentType = self::contentTypes['getGroupMembersIds'][0])
    {

        // verify the required parameter 'groupId' is set
        if ($groupId === null || (is_array($groupId) && count($groupId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $groupId when calling getGroupMembersIds'
            );
        }



        $resourcePath = '/v2/bot/group/{groupId}/members/ids';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($groupId !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($groupId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGroupSummary
     *
     * @param  string $groupId Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupSummary'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\GroupSummaryResponse
     */
    public function getGroupSummary($groupId, string $contentType = self::contentTypes['getGroupSummary'][0])
    {
        list($response) = $this->getGroupSummaryWithHttpInfo($groupId, $contentType);
        return $response;
    }

    /**
     * Operation getGroupSummaryWithHttpInfo
     *
     * @param  string $groupId Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupSummary'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\GroupSummaryResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGroupSummaryWithHttpInfo($groupId, string $contentType = self::contentTypes['getGroupSummary'][0])
    {
        $request = $this->getGroupSummaryRequest($groupId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\GroupSummaryResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\GroupSummaryResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\GroupSummaryResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\GroupSummaryResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\GroupSummaryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGroupSummaryAsync
     *
     * @param  string $groupId Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupSummary'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupSummaryAsync($groupId, string $contentType = self::contentTypes['getGroupSummary'][0])
    {
        return $this->getGroupSummaryAsyncWithHttpInfo($groupId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGroupSummaryAsyncWithHttpInfo
     *
     * @param  string $groupId Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupSummary'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupSummaryAsyncWithHttpInfo($groupId, string $contentType = self::contentTypes['getGroupSummary'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\GroupSummaryResponse';
        $request = $this->getGroupSummaryRequest($groupId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGroupSummary'
     *
     * @param  string $groupId Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupSummary'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGroupSummaryRequest($groupId, string $contentType = self::contentTypes['getGroupSummary'][0])
    {

        // verify the required parameter 'groupId' is set
        if ($groupId === null || (is_array($groupId) && count($groupId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $groupId when calling getGroupSummary'
            );
        }


        $resourcePath = '/v2/bot/group/{groupId}/summary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($groupId !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($groupId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMembershipList
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMembershipList'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\MembershipListResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse
     */
    public function getMembershipList(string $contentType = self::contentTypes['getMembershipList'][0])
    {
        list($response) = $this->getMembershipListWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getMembershipListWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMembershipList'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\MembershipListResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMembershipListWithHttpInfo(string $contentType = self::contentTypes['getMembershipList'][0])
    {
        $request = $this->getMembershipListRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\MembershipListResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\MembershipListResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\MembershipListResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\MembershipListResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\MembershipListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMembershipListAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMembershipList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMembershipListAsync(string $contentType = self::contentTypes['getMembershipList'][0])
    {
        return $this->getMembershipListAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMembershipListAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMembershipList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMembershipListAsyncWithHttpInfo(string $contentType = self::contentTypes['getMembershipList'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\MembershipListResponse';
        $request = $this->getMembershipListRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMembershipList'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMembershipList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMembershipListRequest(string $contentType = self::contentTypes['getMembershipList'][0])
    {


        $resourcePath = '/v2/bot/membership/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMembershipSubscription
     *
     * @param  string $userId User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMembershipSubscription'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\GetMembershipSubscriptionResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse
     */
    public function getMembershipSubscription($userId, string $contentType = self::contentTypes['getMembershipSubscription'][0])
    {
        list($response) = $this->getMembershipSubscriptionWithHttpInfo($userId, $contentType);
        return $response;
    }

    /**
     * Operation getMembershipSubscriptionWithHttpInfo
     *
     * @param  string $userId User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMembershipSubscription'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\GetMembershipSubscriptionResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMembershipSubscriptionWithHttpInfo($userId, string $contentType = self::contentTypes['getMembershipSubscription'][0])
    {
        $request = $this->getMembershipSubscriptionRequest($userId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\GetMembershipSubscriptionResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\GetMembershipSubscriptionResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\GetMembershipSubscriptionResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\GetMembershipSubscriptionResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\GetMembershipSubscriptionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMembershipSubscriptionAsync
     *
     * @param  string $userId User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMembershipSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMembershipSubscriptionAsync($userId, string $contentType = self::contentTypes['getMembershipSubscription'][0])
    {
        return $this->getMembershipSubscriptionAsyncWithHttpInfo($userId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMembershipSubscriptionAsyncWithHttpInfo
     *
     * @param  string $userId User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMembershipSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMembershipSubscriptionAsyncWithHttpInfo($userId, string $contentType = self::contentTypes['getMembershipSubscription'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\GetMembershipSubscriptionResponse';
        $request = $this->getMembershipSubscriptionRequest($userId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMembershipSubscription'
     *
     * @param  string $userId User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMembershipSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMembershipSubscriptionRequest($userId, string $contentType = self::contentTypes['getMembershipSubscription'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling getMembershipSubscription'
            );
        }


        $resourcePath = '/v2/bot/membership/subscription/{userId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMessageQuota
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageQuota'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\MessageQuotaResponse
     */
    public function getMessageQuota(string $contentType = self::contentTypes['getMessageQuota'][0])
    {
        list($response) = $this->getMessageQuotaWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getMessageQuotaWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageQuota'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\MessageQuotaResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMessageQuotaWithHttpInfo(string $contentType = self::contentTypes['getMessageQuota'][0])
    {
        $request = $this->getMessageQuotaRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\MessageQuotaResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\MessageQuotaResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\MessageQuotaResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\MessageQuotaResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\MessageQuotaResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMessageQuotaAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageQuota'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMessageQuotaAsync(string $contentType = self::contentTypes['getMessageQuota'][0])
    {
        return $this->getMessageQuotaAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMessageQuotaAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageQuota'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMessageQuotaAsyncWithHttpInfo(string $contentType = self::contentTypes['getMessageQuota'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\MessageQuotaResponse';
        $request = $this->getMessageQuotaRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMessageQuota'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageQuota'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMessageQuotaRequest(string $contentType = self::contentTypes['getMessageQuota'][0])
    {


        $resourcePath = '/v2/bot/message/quota';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMessageQuotaConsumption
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageQuotaConsumption'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\QuotaConsumptionResponse
     */
    public function getMessageQuotaConsumption(string $contentType = self::contentTypes['getMessageQuotaConsumption'][0])
    {
        list($response) = $this->getMessageQuotaConsumptionWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getMessageQuotaConsumptionWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageQuotaConsumption'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\QuotaConsumptionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMessageQuotaConsumptionWithHttpInfo(string $contentType = self::contentTypes['getMessageQuotaConsumption'][0])
    {
        $request = $this->getMessageQuotaConsumptionRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\QuotaConsumptionResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\QuotaConsumptionResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\QuotaConsumptionResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\QuotaConsumptionResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\QuotaConsumptionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMessageQuotaConsumptionAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageQuotaConsumption'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMessageQuotaConsumptionAsync(string $contentType = self::contentTypes['getMessageQuotaConsumption'][0])
    {
        return $this->getMessageQuotaConsumptionAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMessageQuotaConsumptionAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageQuotaConsumption'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMessageQuotaConsumptionAsyncWithHttpInfo(string $contentType = self::contentTypes['getMessageQuotaConsumption'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\QuotaConsumptionResponse';
        $request = $this->getMessageQuotaConsumptionRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMessageQuotaConsumption'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageQuotaConsumption'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMessageQuotaConsumptionRequest(string $contentType = self::contentTypes['getMessageQuotaConsumption'][0])
    {


        $resourcePath = '/v2/bot/message/quota/consumption';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNarrowcastProgress
     *
     * @param  string $requestId The narrowcast message&#39;s request ID. Each Messaging API request has a request ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNarrowcastProgress'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\NarrowcastProgressResponse
     */
    public function getNarrowcastProgress($requestId, string $contentType = self::contentTypes['getNarrowcastProgress'][0])
    {
        list($response) = $this->getNarrowcastProgressWithHttpInfo($requestId, $contentType);
        return $response;
    }

    /**
     * Operation getNarrowcastProgressWithHttpInfo
     *
     * @param  string $requestId The narrowcast message&#39;s request ID. Each Messaging API request has a request ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNarrowcastProgress'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\NarrowcastProgressResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNarrowcastProgressWithHttpInfo($requestId, string $contentType = self::contentTypes['getNarrowcastProgress'][0])
    {
        $request = $this->getNarrowcastProgressRequest($requestId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\NarrowcastProgressResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\NarrowcastProgressResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\NarrowcastProgressResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\NarrowcastProgressResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\NarrowcastProgressResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNarrowcastProgressAsync
     *
     * @param  string $requestId The narrowcast message&#39;s request ID. Each Messaging API request has a request ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNarrowcastProgress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNarrowcastProgressAsync($requestId, string $contentType = self::contentTypes['getNarrowcastProgress'][0])
    {
        return $this->getNarrowcastProgressAsyncWithHttpInfo($requestId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNarrowcastProgressAsyncWithHttpInfo
     *
     * @param  string $requestId The narrowcast message&#39;s request ID. Each Messaging API request has a request ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNarrowcastProgress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNarrowcastProgressAsyncWithHttpInfo($requestId, string $contentType = self::contentTypes['getNarrowcastProgress'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\NarrowcastProgressResponse';
        $request = $this->getNarrowcastProgressRequest($requestId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNarrowcastProgress'
     *
     * @param  string $requestId The narrowcast message&#39;s request ID. Each Messaging API request has a request ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNarrowcastProgress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNarrowcastProgressRequest($requestId, string $contentType = self::contentTypes['getNarrowcastProgress'][0])
    {

        // verify the required parameter 'requestId' is set
        if ($requestId === null || (is_array($requestId) && count($requestId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $requestId when calling getNarrowcastProgress'
            );
        }


        $resourcePath = '/v2/bot/message/progress/narrowcast';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $requestId,
            'requestId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNumberOfSentBroadcastMessages
     *
     * @param  string $date Date the messages were sent  Format: yyyyMMdd (e.g. 20191231) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentBroadcastMessages'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse
     */
    public function getNumberOfSentBroadcastMessages($date, string $contentType = self::contentTypes['getNumberOfSentBroadcastMessages'][0])
    {
        list($response) = $this->getNumberOfSentBroadcastMessagesWithHttpInfo($date, $contentType);
        return $response;
    }

    /**
     * Operation getNumberOfSentBroadcastMessagesWithHttpInfo
     *
     * @param  string $date Date the messages were sent  Format: yyyyMMdd (e.g. 20191231) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentBroadcastMessages'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNumberOfSentBroadcastMessagesWithHttpInfo($date, string $contentType = self::contentTypes['getNumberOfSentBroadcastMessages'][0])
    {
        $request = $this->getNumberOfSentBroadcastMessagesRequest($date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNumberOfSentBroadcastMessagesAsync
     *
     * @param  string $date Date the messages were sent  Format: yyyyMMdd (e.g. 20191231) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentBroadcastMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNumberOfSentBroadcastMessagesAsync($date, string $contentType = self::contentTypes['getNumberOfSentBroadcastMessages'][0])
    {
        return $this->getNumberOfSentBroadcastMessagesAsyncWithHttpInfo($date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNumberOfSentBroadcastMessagesAsyncWithHttpInfo
     *
     * @param  string $date Date the messages were sent  Format: yyyyMMdd (e.g. 20191231) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentBroadcastMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNumberOfSentBroadcastMessagesAsyncWithHttpInfo($date, string $contentType = self::contentTypes['getNumberOfSentBroadcastMessages'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse';
        $request = $this->getNumberOfSentBroadcastMessagesRequest($date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNumberOfSentBroadcastMessages'
     *
     * @param  string $date Date the messages were sent  Format: yyyyMMdd (e.g. 20191231) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentBroadcastMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNumberOfSentBroadcastMessagesRequest($date, string $contentType = self::contentTypes['getNumberOfSentBroadcastMessages'][0])
    {

        // verify the required parameter 'date' is set
        if ($date === null || (is_array($date) && count($date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $date when calling getNumberOfSentBroadcastMessages'
            );
        }


        $resourcePath = '/v2/bot/message/delivery/broadcast';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date,
            'date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNumberOfSentMulticastMessages
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentMulticastMessages'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse
     */
    public function getNumberOfSentMulticastMessages($date, string $contentType = self::contentTypes['getNumberOfSentMulticastMessages'][0])
    {
        list($response) = $this->getNumberOfSentMulticastMessagesWithHttpInfo($date, $contentType);
        return $response;
    }

    /**
     * Operation getNumberOfSentMulticastMessagesWithHttpInfo
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentMulticastMessages'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNumberOfSentMulticastMessagesWithHttpInfo($date, string $contentType = self::contentTypes['getNumberOfSentMulticastMessages'][0])
    {
        $request = $this->getNumberOfSentMulticastMessagesRequest($date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNumberOfSentMulticastMessagesAsync
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentMulticastMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNumberOfSentMulticastMessagesAsync($date, string $contentType = self::contentTypes['getNumberOfSentMulticastMessages'][0])
    {
        return $this->getNumberOfSentMulticastMessagesAsyncWithHttpInfo($date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNumberOfSentMulticastMessagesAsyncWithHttpInfo
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentMulticastMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNumberOfSentMulticastMessagesAsyncWithHttpInfo($date, string $contentType = self::contentTypes['getNumberOfSentMulticastMessages'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse';
        $request = $this->getNumberOfSentMulticastMessagesRequest($date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNumberOfSentMulticastMessages'
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentMulticastMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNumberOfSentMulticastMessagesRequest($date, string $contentType = self::contentTypes['getNumberOfSentMulticastMessages'][0])
    {

        // verify the required parameter 'date' is set
        if ($date === null || (is_array($date) && count($date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $date when calling getNumberOfSentMulticastMessages'
            );
        }


        $resourcePath = '/v2/bot/message/delivery/multicast';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date,
            'date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNumberOfSentPushMessages
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentPushMessages'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse
     */
    public function getNumberOfSentPushMessages($date, string $contentType = self::contentTypes['getNumberOfSentPushMessages'][0])
    {
        list($response) = $this->getNumberOfSentPushMessagesWithHttpInfo($date, $contentType);
        return $response;
    }

    /**
     * Operation getNumberOfSentPushMessagesWithHttpInfo
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentPushMessages'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNumberOfSentPushMessagesWithHttpInfo($date, string $contentType = self::contentTypes['getNumberOfSentPushMessages'][0])
    {
        $request = $this->getNumberOfSentPushMessagesRequest($date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNumberOfSentPushMessagesAsync
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentPushMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNumberOfSentPushMessagesAsync($date, string $contentType = self::contentTypes['getNumberOfSentPushMessages'][0])
    {
        return $this->getNumberOfSentPushMessagesAsyncWithHttpInfo($date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNumberOfSentPushMessagesAsyncWithHttpInfo
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentPushMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNumberOfSentPushMessagesAsyncWithHttpInfo($date, string $contentType = self::contentTypes['getNumberOfSentPushMessages'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse';
        $request = $this->getNumberOfSentPushMessagesRequest($date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNumberOfSentPushMessages'
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentPushMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNumberOfSentPushMessagesRequest($date, string $contentType = self::contentTypes['getNumberOfSentPushMessages'][0])
    {

        // verify the required parameter 'date' is set
        if ($date === null || (is_array($date) && count($date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $date when calling getNumberOfSentPushMessages'
            );
        }


        $resourcePath = '/v2/bot/message/delivery/push';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date,
            'date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNumberOfSentReplyMessages
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentReplyMessages'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse
     */
    public function getNumberOfSentReplyMessages($date, string $contentType = self::contentTypes['getNumberOfSentReplyMessages'][0])
    {
        list($response) = $this->getNumberOfSentReplyMessagesWithHttpInfo($date, $contentType);
        return $response;
    }

    /**
     * Operation getNumberOfSentReplyMessagesWithHttpInfo
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentReplyMessages'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNumberOfSentReplyMessagesWithHttpInfo($date, string $contentType = self::contentTypes['getNumberOfSentReplyMessages'][0])
    {
        $request = $this->getNumberOfSentReplyMessagesRequest($date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNumberOfSentReplyMessagesAsync
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentReplyMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNumberOfSentReplyMessagesAsync($date, string $contentType = self::contentTypes['getNumberOfSentReplyMessages'][0])
    {
        return $this->getNumberOfSentReplyMessagesAsyncWithHttpInfo($date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNumberOfSentReplyMessagesAsyncWithHttpInfo
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentReplyMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNumberOfSentReplyMessagesAsyncWithHttpInfo($date, string $contentType = self::contentTypes['getNumberOfSentReplyMessages'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse';
        $request = $this->getNumberOfSentReplyMessagesRequest($date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNumberOfSentReplyMessages'
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentReplyMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNumberOfSentReplyMessagesRequest($date, string $contentType = self::contentTypes['getNumberOfSentReplyMessages'][0])
    {

        // verify the required parameter 'date' is set
        if ($date === null || (is_array($date) && count($date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $date when calling getNumberOfSentReplyMessages'
            );
        }


        $resourcePath = '/v2/bot/message/delivery/reply';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date,
            'date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPNPMessageStatistics
     *
     * @param  string $date Date the message was sent  Format: &#x60;yyyyMMdd&#x60; (Example:&#x60;20211231&#x60;) Time zone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPNPMessageStatistics'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse
     */
    public function getPNPMessageStatistics($date, string $contentType = self::contentTypes['getPNPMessageStatistics'][0])
    {
        list($response) = $this->getPNPMessageStatisticsWithHttpInfo($date, $contentType);
        return $response;
    }

    /**
     * Operation getPNPMessageStatisticsWithHttpInfo
     *
     * @param  string $date Date the message was sent  Format: &#x60;yyyyMMdd&#x60; (Example:&#x60;20211231&#x60;) Time zone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPNPMessageStatistics'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPNPMessageStatisticsWithHttpInfo($date, string $contentType = self::contentTypes['getPNPMessageStatistics'][0])
    {
        $request = $this->getPNPMessageStatisticsRequest($date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPNPMessageStatisticsAsync
     *
     * @param  string $date Date the message was sent  Format: &#x60;yyyyMMdd&#x60; (Example:&#x60;20211231&#x60;) Time zone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPNPMessageStatistics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPNPMessageStatisticsAsync($date, string $contentType = self::contentTypes['getPNPMessageStatistics'][0])
    {
        return $this->getPNPMessageStatisticsAsyncWithHttpInfo($date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPNPMessageStatisticsAsyncWithHttpInfo
     *
     * @param  string $date Date the message was sent  Format: &#x60;yyyyMMdd&#x60; (Example:&#x60;20211231&#x60;) Time zone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPNPMessageStatistics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPNPMessageStatisticsAsyncWithHttpInfo($date, string $contentType = self::contentTypes['getPNPMessageStatistics'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\NumberOfMessagesResponse';
        $request = $this->getPNPMessageStatisticsRequest($date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPNPMessageStatistics'
     *
     * @param  string $date Date the message was sent  Format: &#x60;yyyyMMdd&#x60; (Example:&#x60;20211231&#x60;) Time zone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPNPMessageStatistics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPNPMessageStatisticsRequest($date, string $contentType = self::contentTypes['getPNPMessageStatistics'][0])
    {

        // verify the required parameter 'date' is set
        if ($date === null || (is_array($date) && count($date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $date when calling getPNPMessageStatistics'
            );
        }
        if (!preg_match("/^[0-9]{8}$/", $date)) {
            throw new \InvalidArgumentException("invalid value for \"date\" when calling MessagingApiApi.getPNPMessageStatistics, must conform to the pattern /^[0-9]{8}$/.");
        }
        

        $resourcePath = '/v2/bot/message/delivery/pnp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date,
            'date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProfile
     *
     * @param  string $userId User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProfile'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\UserProfileResponse
     */
    public function getProfile($userId, string $contentType = self::contentTypes['getProfile'][0])
    {
        list($response) = $this->getProfileWithHttpInfo($userId, $contentType);
        return $response;
    }

    /**
     * Operation getProfileWithHttpInfo
     *
     * @param  string $userId User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProfile'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\UserProfileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProfileWithHttpInfo($userId, string $contentType = self::contentTypes['getProfile'][0])
    {
        $request = $this->getProfileRequest($userId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\UserProfileResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\UserProfileResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\UserProfileResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\UserProfileResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\UserProfileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProfileAsync
     *
     * @param  string $userId User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProfileAsync($userId, string $contentType = self::contentTypes['getProfile'][0])
    {
        return $this->getProfileAsyncWithHttpInfo($userId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProfileAsyncWithHttpInfo
     *
     * @param  string $userId User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProfileAsyncWithHttpInfo($userId, string $contentType = self::contentTypes['getProfile'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\UserProfileResponse';
        $request = $this->getProfileRequest($userId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProfile'
     *
     * @param  string $userId User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getProfileRequest($userId, string $contentType = self::contentTypes['getProfile'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling getProfile'
            );
        }


        $resourcePath = '/v2/bot/profile/{userId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRichMenu
     *
     * @param  string $richMenuId ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenu'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\RichMenuResponse
     */
    public function getRichMenu($richMenuId, string $contentType = self::contentTypes['getRichMenu'][0])
    {
        list($response) = $this->getRichMenuWithHttpInfo($richMenuId, $contentType);
        return $response;
    }

    /**
     * Operation getRichMenuWithHttpInfo
     *
     * @param  string $richMenuId ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenu'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\RichMenuResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRichMenuWithHttpInfo($richMenuId, string $contentType = self::contentTypes['getRichMenu'][0])
    {
        $request = $this->getRichMenuRequest($richMenuId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\RichMenuResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\RichMenuResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\RichMenuResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\RichMenuResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\RichMenuResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRichMenuAsync
     *
     * @param  string $richMenuId ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRichMenuAsync($richMenuId, string $contentType = self::contentTypes['getRichMenu'][0])
    {
        return $this->getRichMenuAsyncWithHttpInfo($richMenuId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRichMenuAsyncWithHttpInfo
     *
     * @param  string $richMenuId ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRichMenuAsyncWithHttpInfo($richMenuId, string $contentType = self::contentTypes['getRichMenu'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\RichMenuResponse';
        $request = $this->getRichMenuRequest($richMenuId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRichMenu'
     *
     * @param  string $richMenuId ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRichMenuRequest($richMenuId, string $contentType = self::contentTypes['getRichMenu'][0])
    {

        // verify the required parameter 'richMenuId' is set
        if ($richMenuId === null || (is_array($richMenuId) && count($richMenuId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $richMenuId when calling getRichMenu'
            );
        }


        $resourcePath = '/v2/bot/richmenu/{richMenuId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($richMenuId !== null) {
            $resourcePath = str_replace(
                '{' . 'richMenuId' . '}',
                ObjectSerializer::toPathValue($richMenuId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRichMenuAlias
     *
     * @param  string $richMenuAliasId The rich menu alias ID whose information you want to obtain. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\RichMenuAliasResponse
     */
    public function getRichMenuAlias($richMenuAliasId, string $contentType = self::contentTypes['getRichMenuAlias'][0])
    {
        list($response) = $this->getRichMenuAliasWithHttpInfo($richMenuAliasId, $contentType);
        return $response;
    }

    /**
     * Operation getRichMenuAliasWithHttpInfo
     *
     * @param  string $richMenuAliasId The rich menu alias ID whose information you want to obtain. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\RichMenuAliasResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRichMenuAliasWithHttpInfo($richMenuAliasId, string $contentType = self::contentTypes['getRichMenuAlias'][0])
    {
        $request = $this->getRichMenuAliasRequest($richMenuAliasId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\RichMenuAliasResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\RichMenuAliasResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\RichMenuAliasResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\RichMenuAliasResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\RichMenuAliasResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRichMenuAliasAsync
     *
     * @param  string $richMenuAliasId The rich menu alias ID whose information you want to obtain. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRichMenuAliasAsync($richMenuAliasId, string $contentType = self::contentTypes['getRichMenuAlias'][0])
    {
        return $this->getRichMenuAliasAsyncWithHttpInfo($richMenuAliasId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRichMenuAliasAsyncWithHttpInfo
     *
     * @param  string $richMenuAliasId The rich menu alias ID whose information you want to obtain. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRichMenuAliasAsyncWithHttpInfo($richMenuAliasId, string $contentType = self::contentTypes['getRichMenuAlias'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\RichMenuAliasResponse';
        $request = $this->getRichMenuAliasRequest($richMenuAliasId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRichMenuAlias'
     *
     * @param  string $richMenuAliasId The rich menu alias ID whose information you want to obtain. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRichMenuAliasRequest($richMenuAliasId, string $contentType = self::contentTypes['getRichMenuAlias'][0])
    {

        // verify the required parameter 'richMenuAliasId' is set
        if ($richMenuAliasId === null || (is_array($richMenuAliasId) && count($richMenuAliasId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $richMenuAliasId when calling getRichMenuAlias'
            );
        }


        $resourcePath = '/v2/bot/richmenu/alias/{richMenuAliasId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($richMenuAliasId !== null) {
            $resourcePath = str_replace(
                '{' . 'richMenuAliasId' . '}',
                ObjectSerializer::toPathValue($richMenuAliasId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRichMenuAliasList
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuAliasList'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\RichMenuAliasListResponse
     */
    public function getRichMenuAliasList(string $contentType = self::contentTypes['getRichMenuAliasList'][0])
    {
        list($response) = $this->getRichMenuAliasListWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getRichMenuAliasListWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuAliasList'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\RichMenuAliasListResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRichMenuAliasListWithHttpInfo(string $contentType = self::contentTypes['getRichMenuAliasList'][0])
    {
        $request = $this->getRichMenuAliasListRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\RichMenuAliasListResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\RichMenuAliasListResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\RichMenuAliasListResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\RichMenuAliasListResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\RichMenuAliasListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRichMenuAliasListAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuAliasList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRichMenuAliasListAsync(string $contentType = self::contentTypes['getRichMenuAliasList'][0])
    {
        return $this->getRichMenuAliasListAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRichMenuAliasListAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuAliasList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRichMenuAliasListAsyncWithHttpInfo(string $contentType = self::contentTypes['getRichMenuAliasList'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\RichMenuAliasListResponse';
        $request = $this->getRichMenuAliasListRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRichMenuAliasList'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuAliasList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRichMenuAliasListRequest(string $contentType = self::contentTypes['getRichMenuAliasList'][0])
    {


        $resourcePath = '/v2/bot/richmenu/alias/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRichMenuBatchProgress
     *
     * @param  string $requestId A request ID used to batch control the rich menu linked to the user. Each Messaging API request has a request ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuBatchProgress'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\RichMenuBatchProgressResponse
     */
    public function getRichMenuBatchProgress($requestId, string $contentType = self::contentTypes['getRichMenuBatchProgress'][0])
    {
        list($response) = $this->getRichMenuBatchProgressWithHttpInfo($requestId, $contentType);
        return $response;
    }

    /**
     * Operation getRichMenuBatchProgressWithHttpInfo
     *
     * @param  string $requestId A request ID used to batch control the rich menu linked to the user. Each Messaging API request has a request ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuBatchProgress'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\RichMenuBatchProgressResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRichMenuBatchProgressWithHttpInfo($requestId, string $contentType = self::contentTypes['getRichMenuBatchProgress'][0])
    {
        $request = $this->getRichMenuBatchProgressRequest($requestId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\RichMenuBatchProgressResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\RichMenuBatchProgressResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\RichMenuBatchProgressResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\RichMenuBatchProgressResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\RichMenuBatchProgressResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRichMenuBatchProgressAsync
     *
     * @param  string $requestId A request ID used to batch control the rich menu linked to the user. Each Messaging API request has a request ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuBatchProgress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRichMenuBatchProgressAsync($requestId, string $contentType = self::contentTypes['getRichMenuBatchProgress'][0])
    {
        return $this->getRichMenuBatchProgressAsyncWithHttpInfo($requestId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRichMenuBatchProgressAsyncWithHttpInfo
     *
     * @param  string $requestId A request ID used to batch control the rich menu linked to the user. Each Messaging API request has a request ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuBatchProgress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRichMenuBatchProgressAsyncWithHttpInfo($requestId, string $contentType = self::contentTypes['getRichMenuBatchProgress'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\RichMenuBatchProgressResponse';
        $request = $this->getRichMenuBatchProgressRequest($requestId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRichMenuBatchProgress'
     *
     * @param  string $requestId A request ID used to batch control the rich menu linked to the user. Each Messaging API request has a request ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuBatchProgress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRichMenuBatchProgressRequest($requestId, string $contentType = self::contentTypes['getRichMenuBatchProgress'][0])
    {

        // verify the required parameter 'requestId' is set
        if ($requestId === null || (is_array($requestId) && count($requestId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $requestId when calling getRichMenuBatchProgress'
            );
        }


        $resourcePath = '/v2/bot/richmenu/progress/batch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $requestId,
            'requestId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRichMenuIdOfUser
     *
     * @param  string $userId User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuIdOfUser'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\RichMenuIdResponse
     */
    public function getRichMenuIdOfUser($userId, string $contentType = self::contentTypes['getRichMenuIdOfUser'][0])
    {
        list($response) = $this->getRichMenuIdOfUserWithHttpInfo($userId, $contentType);
        return $response;
    }

    /**
     * Operation getRichMenuIdOfUserWithHttpInfo
     *
     * @param  string $userId User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuIdOfUser'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\RichMenuIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRichMenuIdOfUserWithHttpInfo($userId, string $contentType = self::contentTypes['getRichMenuIdOfUser'][0])
    {
        $request = $this->getRichMenuIdOfUserRequest($userId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\RichMenuIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\RichMenuIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\RichMenuIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\RichMenuIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\RichMenuIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRichMenuIdOfUserAsync
     *
     * @param  string $userId User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuIdOfUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRichMenuIdOfUserAsync($userId, string $contentType = self::contentTypes['getRichMenuIdOfUser'][0])
    {
        return $this->getRichMenuIdOfUserAsyncWithHttpInfo($userId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRichMenuIdOfUserAsyncWithHttpInfo
     *
     * @param  string $userId User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuIdOfUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRichMenuIdOfUserAsyncWithHttpInfo($userId, string $contentType = self::contentTypes['getRichMenuIdOfUser'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\RichMenuIdResponse';
        $request = $this->getRichMenuIdOfUserRequest($userId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRichMenuIdOfUser'
     *
     * @param  string $userId User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuIdOfUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRichMenuIdOfUserRequest($userId, string $contentType = self::contentTypes['getRichMenuIdOfUser'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling getRichMenuIdOfUser'
            );
        }


        $resourcePath = '/v2/bot/user/{userId}/richmenu';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRichMenuList
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuList'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\RichMenuListResponse
     */
    public function getRichMenuList(string $contentType = self::contentTypes['getRichMenuList'][0])
    {
        list($response) = $this->getRichMenuListWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getRichMenuListWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuList'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\RichMenuListResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRichMenuListWithHttpInfo(string $contentType = self::contentTypes['getRichMenuList'][0])
    {
        $request = $this->getRichMenuListRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\RichMenuListResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\RichMenuListResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\RichMenuListResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\RichMenuListResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\RichMenuListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRichMenuListAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRichMenuListAsync(string $contentType = self::contentTypes['getRichMenuList'][0])
    {
        return $this->getRichMenuListAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRichMenuListAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRichMenuListAsyncWithHttpInfo(string $contentType = self::contentTypes['getRichMenuList'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\RichMenuListResponse';
        $request = $this->getRichMenuListRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRichMenuList'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRichMenuListRequest(string $contentType = self::contentTypes['getRichMenuList'][0])
    {


        $resourcePath = '/v2/bot/richmenu/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRoomMemberCount
     *
     * @param  string $roomId Room ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMemberCount'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\RoomMemberCountResponse
     */
    public function getRoomMemberCount($roomId, string $contentType = self::contentTypes['getRoomMemberCount'][0])
    {
        list($response) = $this->getRoomMemberCountWithHttpInfo($roomId, $contentType);
        return $response;
    }

    /**
     * Operation getRoomMemberCountWithHttpInfo
     *
     * @param  string $roomId Room ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMemberCount'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\RoomMemberCountResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRoomMemberCountWithHttpInfo($roomId, string $contentType = self::contentTypes['getRoomMemberCount'][0])
    {
        $request = $this->getRoomMemberCountRequest($roomId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\RoomMemberCountResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\RoomMemberCountResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\RoomMemberCountResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\RoomMemberCountResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\RoomMemberCountResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRoomMemberCountAsync
     *
     * @param  string $roomId Room ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMemberCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomMemberCountAsync($roomId, string $contentType = self::contentTypes['getRoomMemberCount'][0])
    {
        return $this->getRoomMemberCountAsyncWithHttpInfo($roomId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRoomMemberCountAsyncWithHttpInfo
     *
     * @param  string $roomId Room ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMemberCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomMemberCountAsyncWithHttpInfo($roomId, string $contentType = self::contentTypes['getRoomMemberCount'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\RoomMemberCountResponse';
        $request = $this->getRoomMemberCountRequest($roomId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRoomMemberCount'
     *
     * @param  string $roomId Room ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMemberCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRoomMemberCountRequest($roomId, string $contentType = self::contentTypes['getRoomMemberCount'][0])
    {

        // verify the required parameter 'roomId' is set
        if ($roomId === null || (is_array($roomId) && count($roomId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $roomId when calling getRoomMemberCount'
            );
        }


        $resourcePath = '/v2/bot/room/{roomId}/members/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($roomId !== null) {
            $resourcePath = str_replace(
                '{' . 'roomId' . '}',
                ObjectSerializer::toPathValue($roomId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRoomMemberProfile
     *
     * @param  string $roomId Room ID (required)
     * @param  string $userId User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMemberProfile'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\RoomUserProfileResponse
     */
    public function getRoomMemberProfile($roomId, $userId, string $contentType = self::contentTypes['getRoomMemberProfile'][0])
    {
        list($response) = $this->getRoomMemberProfileWithHttpInfo($roomId, $userId, $contentType);
        return $response;
    }

    /**
     * Operation getRoomMemberProfileWithHttpInfo
     *
     * @param  string $roomId Room ID (required)
     * @param  string $userId User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMemberProfile'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\RoomUserProfileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRoomMemberProfileWithHttpInfo($roomId, $userId, string $contentType = self::contentTypes['getRoomMemberProfile'][0])
    {
        $request = $this->getRoomMemberProfileRequest($roomId, $userId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\RoomUserProfileResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\RoomUserProfileResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\RoomUserProfileResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\RoomUserProfileResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\RoomUserProfileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRoomMemberProfileAsync
     *
     * @param  string $roomId Room ID (required)
     * @param  string $userId User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMemberProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomMemberProfileAsync($roomId, $userId, string $contentType = self::contentTypes['getRoomMemberProfile'][0])
    {
        return $this->getRoomMemberProfileAsyncWithHttpInfo($roomId, $userId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRoomMemberProfileAsyncWithHttpInfo
     *
     * @param  string $roomId Room ID (required)
     * @param  string $userId User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMemberProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomMemberProfileAsyncWithHttpInfo($roomId, $userId, string $contentType = self::contentTypes['getRoomMemberProfile'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\RoomUserProfileResponse';
        $request = $this->getRoomMemberProfileRequest($roomId, $userId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRoomMemberProfile'
     *
     * @param  string $roomId Room ID (required)
     * @param  string $userId User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMemberProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRoomMemberProfileRequest($roomId, $userId, string $contentType = self::contentTypes['getRoomMemberProfile'][0])
    {

        // verify the required parameter 'roomId' is set
        if ($roomId === null || (is_array($roomId) && count($roomId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $roomId when calling getRoomMemberProfile'
            );
        }

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling getRoomMemberProfile'
            );
        }


        $resourcePath = '/v2/bot/room/{roomId}/member/{userId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($roomId !== null) {
            $resourcePath = str_replace(
                '{' . 'roomId' . '}',
                ObjectSerializer::toPathValue($roomId),
                $resourcePath
            );
        }
        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRoomMembersIds
     *
     * @param  string $roomId Room ID (required)
     * @param  string $start Value of the continuation token found in the &#x60;next&#x60; property of the JSON object returned in the response. Include this parameter to get the next array of user IDs for the members of the group. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMembersIds'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\MembersIdsResponse
     */
    public function getRoomMembersIds($roomId, $start = null, string $contentType = self::contentTypes['getRoomMembersIds'][0])
    {
        list($response) = $this->getRoomMembersIdsWithHttpInfo($roomId, $start, $contentType);
        return $response;
    }

    /**
     * Operation getRoomMembersIdsWithHttpInfo
     *
     * @param  string $roomId Room ID (required)
     * @param  string $start Value of the continuation token found in the &#x60;next&#x60; property of the JSON object returned in the response. Include this parameter to get the next array of user IDs for the members of the group. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMembersIds'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\MembersIdsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRoomMembersIdsWithHttpInfo($roomId, $start = null, string $contentType = self::contentTypes['getRoomMembersIds'][0])
    {
        $request = $this->getRoomMembersIdsRequest($roomId, $start, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\MembersIdsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\MembersIdsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\MembersIdsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\MembersIdsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\MembersIdsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRoomMembersIdsAsync
     *
     * @param  string $roomId Room ID (required)
     * @param  string $start Value of the continuation token found in the &#x60;next&#x60; property of the JSON object returned in the response. Include this parameter to get the next array of user IDs for the members of the group. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMembersIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomMembersIdsAsync($roomId, $start = null, string $contentType = self::contentTypes['getRoomMembersIds'][0])
    {
        return $this->getRoomMembersIdsAsyncWithHttpInfo($roomId, $start, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRoomMembersIdsAsyncWithHttpInfo
     *
     * @param  string $roomId Room ID (required)
     * @param  string $start Value of the continuation token found in the &#x60;next&#x60; property of the JSON object returned in the response. Include this parameter to get the next array of user IDs for the members of the group. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMembersIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomMembersIdsAsyncWithHttpInfo($roomId, $start = null, string $contentType = self::contentTypes['getRoomMembersIds'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\MembersIdsResponse';
        $request = $this->getRoomMembersIdsRequest($roomId, $start, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRoomMembersIds'
     *
     * @param  string $roomId Room ID (required)
     * @param  string $start Value of the continuation token found in the &#x60;next&#x60; property of the JSON object returned in the response. Include this parameter to get the next array of user IDs for the members of the group. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMembersIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRoomMembersIdsRequest($roomId, $start = null, string $contentType = self::contentTypes['getRoomMembersIds'][0])
    {

        // verify the required parameter 'roomId' is set
        if ($roomId === null || (is_array($roomId) && count($roomId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $roomId when calling getRoomMembersIds'
            );
        }



        $resourcePath = '/v2/bot/room/{roomId}/members/ids';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($roomId !== null) {
            $resourcePath = str_replace(
                '{' . 'roomId' . '}',
                ObjectSerializer::toPathValue($roomId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWebhookEndpoint
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\GetWebhookEndpointResponse
     */
    public function getWebhookEndpoint(string $contentType = self::contentTypes['getWebhookEndpoint'][0])
    {
        list($response) = $this->getWebhookEndpointWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getWebhookEndpointWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\GetWebhookEndpointResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWebhookEndpointWithHttpInfo(string $contentType = self::contentTypes['getWebhookEndpoint'][0])
    {
        $request = $this->getWebhookEndpointRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\GetWebhookEndpointResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\GetWebhookEndpointResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\GetWebhookEndpointResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\GetWebhookEndpointResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\GetWebhookEndpointResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWebhookEndpointAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebhookEndpointAsync(string $contentType = self::contentTypes['getWebhookEndpoint'][0])
    {
        return $this->getWebhookEndpointAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWebhookEndpointAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebhookEndpointAsyncWithHttpInfo(string $contentType = self::contentTypes['getWebhookEndpoint'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\GetWebhookEndpointResponse';
        $request = $this->getWebhookEndpointRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWebhookEndpoint'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getWebhookEndpointRequest(string $contentType = self::contentTypes['getWebhookEndpoint'][0])
    {


        $resourcePath = '/v2/bot/channel/webhook/endpoint';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueLinkToken
     *
     * @param  string $userId User ID for the LINE account to be linked. Found in the &#x60;source&#x60; object of account link event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['issueLinkToken'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\IssueLinkTokenResponse
     */
    public function issueLinkToken($userId, string $contentType = self::contentTypes['issueLinkToken'][0])
    {
        list($response) = $this->issueLinkTokenWithHttpInfo($userId, $contentType);
        return $response;
    }

    /**
     * Operation issueLinkTokenWithHttpInfo
     *
     * @param  string $userId User ID for the LINE account to be linked. Found in the &#x60;source&#x60; object of account link event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['issueLinkToken'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\IssueLinkTokenResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueLinkTokenWithHttpInfo($userId, string $contentType = self::contentTypes['issueLinkToken'][0])
    {
        $request = $this->issueLinkTokenRequest($userId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\IssueLinkTokenResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\IssueLinkTokenResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\IssueLinkTokenResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\IssueLinkTokenResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\IssueLinkTokenResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueLinkTokenAsync
     *
     * @param  string $userId User ID for the LINE account to be linked. Found in the &#x60;source&#x60; object of account link event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['issueLinkToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueLinkTokenAsync($userId, string $contentType = self::contentTypes['issueLinkToken'][0])
    {
        return $this->issueLinkTokenAsyncWithHttpInfo($userId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueLinkTokenAsyncWithHttpInfo
     *
     * @param  string $userId User ID for the LINE account to be linked. Found in the &#x60;source&#x60; object of account link event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['issueLinkToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueLinkTokenAsyncWithHttpInfo($userId, string $contentType = self::contentTypes['issueLinkToken'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\IssueLinkTokenResponse';
        $request = $this->issueLinkTokenRequest($userId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueLinkToken'
     *
     * @param  string $userId User ID for the LINE account to be linked. Found in the &#x60;source&#x60; object of account link event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['issueLinkToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueLinkTokenRequest($userId, string $contentType = self::contentTypes['issueLinkToken'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling issueLinkToken'
            );
        }


        $resourcePath = '/v2/bot/user/{userId}/linkToken';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation leaveGroup
     *
     * @param  string $groupId Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveGroup'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function leaveGroup($groupId, string $contentType = self::contentTypes['leaveGroup'][0])
    {
        $this->leaveGroupWithHttpInfo($groupId, $contentType);
    }

    /**
     * Operation leaveGroupWithHttpInfo
     *
     * @param  string $groupId Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveGroup'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function leaveGroupWithHttpInfo($groupId, string $contentType = self::contentTypes['leaveGroup'][0])
    {
        $request = $this->leaveGroupRequest($groupId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation leaveGroupAsync
     *
     * @param  string $groupId Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaveGroupAsync($groupId, string $contentType = self::contentTypes['leaveGroup'][0])
    {
        return $this->leaveGroupAsyncWithHttpInfo($groupId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation leaveGroupAsyncWithHttpInfo
     *
     * @param  string $groupId Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaveGroupAsyncWithHttpInfo($groupId, string $contentType = self::contentTypes['leaveGroup'][0])
    {
        $returnType = '';
        $request = $this->leaveGroupRequest($groupId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'leaveGroup'
     *
     * @param  string $groupId Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function leaveGroupRequest($groupId, string $contentType = self::contentTypes['leaveGroup'][0])
    {

        // verify the required parameter 'groupId' is set
        if ($groupId === null || (is_array($groupId) && count($groupId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $groupId when calling leaveGroup'
            );
        }


        $resourcePath = '/v2/bot/group/{groupId}/leave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($groupId !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($groupId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation leaveRoom
     *
     * @param  string $roomId Room ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveRoom'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function leaveRoom($roomId, string $contentType = self::contentTypes['leaveRoom'][0])
    {
        $this->leaveRoomWithHttpInfo($roomId, $contentType);
    }

    /**
     * Operation leaveRoomWithHttpInfo
     *
     * @param  string $roomId Room ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveRoom'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function leaveRoomWithHttpInfo($roomId, string $contentType = self::contentTypes['leaveRoom'][0])
    {
        $request = $this->leaveRoomRequest($roomId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation leaveRoomAsync
     *
     * @param  string $roomId Room ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaveRoomAsync($roomId, string $contentType = self::contentTypes['leaveRoom'][0])
    {
        return $this->leaveRoomAsyncWithHttpInfo($roomId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation leaveRoomAsyncWithHttpInfo
     *
     * @param  string $roomId Room ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaveRoomAsyncWithHttpInfo($roomId, string $contentType = self::contentTypes['leaveRoom'][0])
    {
        $returnType = '';
        $request = $this->leaveRoomRequest($roomId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'leaveRoom'
     *
     * @param  string $roomId Room ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function leaveRoomRequest($roomId, string $contentType = self::contentTypes['leaveRoom'][0])
    {

        // verify the required parameter 'roomId' is set
        if ($roomId === null || (is_array($roomId) && count($roomId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $roomId when calling leaveRoom'
            );
        }


        $resourcePath = '/v2/bot/room/{roomId}/leave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($roomId !== null) {
            $resourcePath = str_replace(
                '{' . 'roomId' . '}',
                ObjectSerializer::toPathValue($roomId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation linkRichMenuIdToUser
     *
     * @param  string $userId User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $richMenuId ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['linkRichMenuIdToUser'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function linkRichMenuIdToUser($userId, $richMenuId, string $contentType = self::contentTypes['linkRichMenuIdToUser'][0])
    {
        $this->linkRichMenuIdToUserWithHttpInfo($userId, $richMenuId, $contentType);
    }

    /**
     * Operation linkRichMenuIdToUserWithHttpInfo
     *
     * @param  string $userId User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $richMenuId ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['linkRichMenuIdToUser'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function linkRichMenuIdToUserWithHttpInfo($userId, $richMenuId, string $contentType = self::contentTypes['linkRichMenuIdToUser'][0])
    {
        $request = $this->linkRichMenuIdToUserRequest($userId, $richMenuId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation linkRichMenuIdToUserAsync
     *
     * @param  string $userId User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $richMenuId ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['linkRichMenuIdToUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function linkRichMenuIdToUserAsync($userId, $richMenuId, string $contentType = self::contentTypes['linkRichMenuIdToUser'][0])
    {
        return $this->linkRichMenuIdToUserAsyncWithHttpInfo($userId, $richMenuId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation linkRichMenuIdToUserAsyncWithHttpInfo
     *
     * @param  string $userId User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $richMenuId ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['linkRichMenuIdToUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function linkRichMenuIdToUserAsyncWithHttpInfo($userId, $richMenuId, string $contentType = self::contentTypes['linkRichMenuIdToUser'][0])
    {
        $returnType = '';
        $request = $this->linkRichMenuIdToUserRequest($userId, $richMenuId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'linkRichMenuIdToUser'
     *
     * @param  string $userId User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $richMenuId ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['linkRichMenuIdToUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function linkRichMenuIdToUserRequest($userId, $richMenuId, string $contentType = self::contentTypes['linkRichMenuIdToUser'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling linkRichMenuIdToUser'
            );
        }

        // verify the required parameter 'richMenuId' is set
        if ($richMenuId === null || (is_array($richMenuId) && count($richMenuId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $richMenuId when calling linkRichMenuIdToUser'
            );
        }


        $resourcePath = '/v2/bot/user/{userId}/richmenu/{richMenuId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }
        // path params
        if ($richMenuId !== null) {
            $resourcePath = str_replace(
                '{' . 'richMenuId' . '}',
                ObjectSerializer::toPathValue($richMenuId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation linkRichMenuIdToUsers
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuBulkLinkRequest $richMenuBulkLinkRequest richMenuBulkLinkRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['linkRichMenuIdToUsers'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function linkRichMenuIdToUsers($richMenuBulkLinkRequest, string $contentType = self::contentTypes['linkRichMenuIdToUsers'][0])
    {
        $this->linkRichMenuIdToUsersWithHttpInfo($richMenuBulkLinkRequest, $contentType);
    }

    /**
     * Operation linkRichMenuIdToUsersWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuBulkLinkRequest $richMenuBulkLinkRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['linkRichMenuIdToUsers'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function linkRichMenuIdToUsersWithHttpInfo($richMenuBulkLinkRequest, string $contentType = self::contentTypes['linkRichMenuIdToUsers'][0])
    {
        $request = $this->linkRichMenuIdToUsersRequest($richMenuBulkLinkRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation linkRichMenuIdToUsersAsync
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuBulkLinkRequest $richMenuBulkLinkRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['linkRichMenuIdToUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function linkRichMenuIdToUsersAsync($richMenuBulkLinkRequest, string $contentType = self::contentTypes['linkRichMenuIdToUsers'][0])
    {
        return $this->linkRichMenuIdToUsersAsyncWithHttpInfo($richMenuBulkLinkRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation linkRichMenuIdToUsersAsyncWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuBulkLinkRequest $richMenuBulkLinkRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['linkRichMenuIdToUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function linkRichMenuIdToUsersAsyncWithHttpInfo($richMenuBulkLinkRequest, string $contentType = self::contentTypes['linkRichMenuIdToUsers'][0])
    {
        $returnType = '';
        $request = $this->linkRichMenuIdToUsersRequest($richMenuBulkLinkRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'linkRichMenuIdToUsers'
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuBulkLinkRequest $richMenuBulkLinkRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['linkRichMenuIdToUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function linkRichMenuIdToUsersRequest($richMenuBulkLinkRequest, string $contentType = self::contentTypes['linkRichMenuIdToUsers'][0])
    {

        // verify the required parameter 'richMenuBulkLinkRequest' is set
        if ($richMenuBulkLinkRequest === null || (is_array($richMenuBulkLinkRequest) && count($richMenuBulkLinkRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $richMenuBulkLinkRequest when calling linkRichMenuIdToUsers'
            );
        }


        $resourcePath = '/v2/bot/richmenu/bulk/link';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($richMenuBulkLinkRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($richMenuBulkLinkRequest));
            } else {
                $httpBody = $richMenuBulkLinkRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation markMessagesAsRead
     *
     * @param  \LINE\Clients\MessagingApi\Model\MarkMessagesAsReadRequest $markMessagesAsReadRequest markMessagesAsReadRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['markMessagesAsRead'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function markMessagesAsRead($markMessagesAsReadRequest, string $contentType = self::contentTypes['markMessagesAsRead'][0])
    {
        $this->markMessagesAsReadWithHttpInfo($markMessagesAsReadRequest, $contentType);
    }

    /**
     * Operation markMessagesAsReadWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\MarkMessagesAsReadRequest $markMessagesAsReadRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['markMessagesAsRead'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function markMessagesAsReadWithHttpInfo($markMessagesAsReadRequest, string $contentType = self::contentTypes['markMessagesAsRead'][0])
    {
        $request = $this->markMessagesAsReadRequest($markMessagesAsReadRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation markMessagesAsReadAsync
     *
     * @param  \LINE\Clients\MessagingApi\Model\MarkMessagesAsReadRequest $markMessagesAsReadRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['markMessagesAsRead'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function markMessagesAsReadAsync($markMessagesAsReadRequest, string $contentType = self::contentTypes['markMessagesAsRead'][0])
    {
        return $this->markMessagesAsReadAsyncWithHttpInfo($markMessagesAsReadRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation markMessagesAsReadAsyncWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\MarkMessagesAsReadRequest $markMessagesAsReadRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['markMessagesAsRead'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function markMessagesAsReadAsyncWithHttpInfo($markMessagesAsReadRequest, string $contentType = self::contentTypes['markMessagesAsRead'][0])
    {
        $returnType = '';
        $request = $this->markMessagesAsReadRequest($markMessagesAsReadRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'markMessagesAsRead'
     *
     * @param  \LINE\Clients\MessagingApi\Model\MarkMessagesAsReadRequest $markMessagesAsReadRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['markMessagesAsRead'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function markMessagesAsReadRequest($markMessagesAsReadRequest, string $contentType = self::contentTypes['markMessagesAsRead'][0])
    {

        // verify the required parameter 'markMessagesAsReadRequest' is set
        if ($markMessagesAsReadRequest === null || (is_array($markMessagesAsReadRequest) && count($markMessagesAsReadRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $markMessagesAsReadRequest when calling markMessagesAsRead'
            );
        }


        $resourcePath = '/v2/bot/message/markAsRead';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($markMessagesAsReadRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($markMessagesAsReadRequest));
            } else {
                $httpBody = $markMessagesAsReadRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation multicast
     *
     * @param  \LINE\Clients\MessagingApi\Model\MulticastRequest $multicastRequest multicastRequest (required)
     * @param  string $xLineRetryKey Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['multicast'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\LINE\Clients\MessagingApi\Model\ErrorResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse
     */
    public function multicast($multicastRequest, $xLineRetryKey = null, string $contentType = self::contentTypes['multicast'][0])
    {
        list($response) = $this->multicastWithHttpInfo($multicastRequest, $xLineRetryKey, $contentType);
        return $response;
    }

    /**
     * Operation multicastWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\MulticastRequest $multicastRequest (required)
     * @param  string $xLineRetryKey Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['multicast'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\LINE\Clients\MessagingApi\Model\ErrorResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function multicastWithHttpInfo($multicastRequest, $xLineRetryKey = null, string $contentType = self::contentTypes['multicast'][0])
    {
        $request = $this->multicastRequest($multicastRequest, $xLineRetryKey, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation multicastAsync
     *
     * @param  \LINE\Clients\MessagingApi\Model\MulticastRequest $multicastRequest (required)
     * @param  string $xLineRetryKey Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['multicast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function multicastAsync($multicastRequest, $xLineRetryKey = null, string $contentType = self::contentTypes['multicast'][0])
    {
        return $this->multicastAsyncWithHttpInfo($multicastRequest, $xLineRetryKey, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation multicastAsyncWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\MulticastRequest $multicastRequest (required)
     * @param  string $xLineRetryKey Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['multicast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function multicastAsyncWithHttpInfo($multicastRequest, $xLineRetryKey = null, string $contentType = self::contentTypes['multicast'][0])
    {
        $returnType = 'object';
        $request = $this->multicastRequest($multicastRequest, $xLineRetryKey, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'multicast'
     *
     * @param  \LINE\Clients\MessagingApi\Model\MulticastRequest $multicastRequest (required)
     * @param  string $xLineRetryKey Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['multicast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function multicastRequest($multicastRequest, $xLineRetryKey = null, string $contentType = self::contentTypes['multicast'][0])
    {

        // verify the required parameter 'multicastRequest' is set
        if ($multicastRequest === null || (is_array($multicastRequest) && count($multicastRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $multicastRequest when calling multicast'
            );
        }



        $resourcePath = '/v2/bot/message/multicast';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($xLineRetryKey !== null) {
            $headerParams['X-Line-Retry-Key'] = ObjectSerializer::toHeaderValue($xLineRetryKey);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($multicastRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($multicastRequest));
            } else {
                $httpBody = $multicastRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation narrowcast
     *
     * @param  \LINE\Clients\MessagingApi\Model\NarrowcastRequest $narrowcastRequest narrowcastRequest (required)
     * @param  string $xLineRetryKey Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['narrowcast'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\LINE\Clients\MessagingApi\Model\ErrorResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse
     */
    public function narrowcast($narrowcastRequest, $xLineRetryKey = null, string $contentType = self::contentTypes['narrowcast'][0])
    {
        list($response) = $this->narrowcastWithHttpInfo($narrowcastRequest, $xLineRetryKey, $contentType);
        return $response;
    }

    /**
     * Operation narrowcastWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\NarrowcastRequest $narrowcastRequest (required)
     * @param  string $xLineRetryKey Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['narrowcast'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\LINE\Clients\MessagingApi\Model\ErrorResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function narrowcastWithHttpInfo($narrowcastRequest, $xLineRetryKey = null, string $contentType = self::contentTypes['narrowcast'][0])
    {
        $request = $this->narrowcastRequest($narrowcastRequest, $xLineRetryKey, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 202:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation narrowcastAsync
     *
     * @param  \LINE\Clients\MessagingApi\Model\NarrowcastRequest $narrowcastRequest (required)
     * @param  string $xLineRetryKey Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['narrowcast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function narrowcastAsync($narrowcastRequest, $xLineRetryKey = null, string $contentType = self::contentTypes['narrowcast'][0])
    {
        return $this->narrowcastAsyncWithHttpInfo($narrowcastRequest, $xLineRetryKey, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation narrowcastAsyncWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\NarrowcastRequest $narrowcastRequest (required)
     * @param  string $xLineRetryKey Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['narrowcast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function narrowcastAsyncWithHttpInfo($narrowcastRequest, $xLineRetryKey = null, string $contentType = self::contentTypes['narrowcast'][0])
    {
        $returnType = 'object';
        $request = $this->narrowcastRequest($narrowcastRequest, $xLineRetryKey, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'narrowcast'
     *
     * @param  \LINE\Clients\MessagingApi\Model\NarrowcastRequest $narrowcastRequest (required)
     * @param  string $xLineRetryKey Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['narrowcast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function narrowcastRequest($narrowcastRequest, $xLineRetryKey = null, string $contentType = self::contentTypes['narrowcast'][0])
    {

        // verify the required parameter 'narrowcastRequest' is set
        if ($narrowcastRequest === null || (is_array($narrowcastRequest) && count($narrowcastRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $narrowcastRequest when calling narrowcast'
            );
        }



        $resourcePath = '/v2/bot/message/narrowcast';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($xLineRetryKey !== null) {
            $headerParams['X-Line-Retry-Key'] = ObjectSerializer::toHeaderValue($xLineRetryKey);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($narrowcastRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($narrowcastRequest));
            } else {
                $httpBody = $narrowcastRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pushMessage
     *
     * @param  \LINE\Clients\MessagingApi\Model\PushMessageRequest $pushMessageRequest pushMessageRequest (required)
     * @param  string $xLineRetryKey Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pushMessage'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\PushMessageResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse
     */
    public function pushMessage($pushMessageRequest, $xLineRetryKey = null, string $contentType = self::contentTypes['pushMessage'][0])
    {
        list($response) = $this->pushMessageWithHttpInfo($pushMessageRequest, $xLineRetryKey, $contentType);
        return $response;
    }

    /**
     * Operation pushMessageWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\PushMessageRequest $pushMessageRequest (required)
     * @param  string $xLineRetryKey Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pushMessage'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\PushMessageResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pushMessageWithHttpInfo($pushMessageRequest, $xLineRetryKey = null, string $contentType = self::contentTypes['pushMessage'][0])
    {
        $request = $this->pushMessageRequest($pushMessageRequest, $xLineRetryKey, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\PushMessageResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\PushMessageResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\PushMessageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\PushMessageResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\PushMessageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pushMessageAsync
     *
     * @param  \LINE\Clients\MessagingApi\Model\PushMessageRequest $pushMessageRequest (required)
     * @param  string $xLineRetryKey Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pushMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pushMessageAsync($pushMessageRequest, $xLineRetryKey = null, string $contentType = self::contentTypes['pushMessage'][0])
    {
        return $this->pushMessageAsyncWithHttpInfo($pushMessageRequest, $xLineRetryKey, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pushMessageAsyncWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\PushMessageRequest $pushMessageRequest (required)
     * @param  string $xLineRetryKey Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pushMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pushMessageAsyncWithHttpInfo($pushMessageRequest, $xLineRetryKey = null, string $contentType = self::contentTypes['pushMessage'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\PushMessageResponse';
        $request = $this->pushMessageRequest($pushMessageRequest, $xLineRetryKey, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pushMessage'
     *
     * @param  \LINE\Clients\MessagingApi\Model\PushMessageRequest $pushMessageRequest (required)
     * @param  string $xLineRetryKey Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pushMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function pushMessageRequest($pushMessageRequest, $xLineRetryKey = null, string $contentType = self::contentTypes['pushMessage'][0])
    {

        // verify the required parameter 'pushMessageRequest' is set
        if ($pushMessageRequest === null || (is_array($pushMessageRequest) && count($pushMessageRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pushMessageRequest when calling pushMessage'
            );
        }



        $resourcePath = '/v2/bot/message/push';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($xLineRetryKey !== null) {
            $headerParams['X-Line-Retry-Key'] = ObjectSerializer::toHeaderValue($xLineRetryKey);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($pushMessageRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($pushMessageRequest));
            } else {
                $httpBody = $pushMessageRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pushMessagesByPhone
     *
     * @param  \LINE\Clients\MessagingApi\Model\PnpMessagesRequest $pnpMessagesRequest pnpMessagesRequest (required)
     * @param  string $xLineDeliveryTag String returned in the delivery.data property of the delivery completion event via Webhook. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pushMessagesByPhone'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function pushMessagesByPhone($pnpMessagesRequest, $xLineDeliveryTag = null, string $contentType = self::contentTypes['pushMessagesByPhone'][0])
    {
        $this->pushMessagesByPhoneWithHttpInfo($pnpMessagesRequest, $xLineDeliveryTag, $contentType);
    }

    /**
     * Operation pushMessagesByPhoneWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\PnpMessagesRequest $pnpMessagesRequest (required)
     * @param  string $xLineDeliveryTag String returned in the delivery.data property of the delivery completion event via Webhook. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pushMessagesByPhone'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function pushMessagesByPhoneWithHttpInfo($pnpMessagesRequest, $xLineDeliveryTag = null, string $contentType = self::contentTypes['pushMessagesByPhone'][0])
    {
        $request = $this->pushMessagesByPhoneRequest($pnpMessagesRequest, $xLineDeliveryTag, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pushMessagesByPhoneAsync
     *
     * @param  \LINE\Clients\MessagingApi\Model\PnpMessagesRequest $pnpMessagesRequest (required)
     * @param  string $xLineDeliveryTag String returned in the delivery.data property of the delivery completion event via Webhook. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pushMessagesByPhone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pushMessagesByPhoneAsync($pnpMessagesRequest, $xLineDeliveryTag = null, string $contentType = self::contentTypes['pushMessagesByPhone'][0])
    {
        return $this->pushMessagesByPhoneAsyncWithHttpInfo($pnpMessagesRequest, $xLineDeliveryTag, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pushMessagesByPhoneAsyncWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\PnpMessagesRequest $pnpMessagesRequest (required)
     * @param  string $xLineDeliveryTag String returned in the delivery.data property of the delivery completion event via Webhook. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pushMessagesByPhone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pushMessagesByPhoneAsyncWithHttpInfo($pnpMessagesRequest, $xLineDeliveryTag = null, string $contentType = self::contentTypes['pushMessagesByPhone'][0])
    {
        $returnType = '';
        $request = $this->pushMessagesByPhoneRequest($pnpMessagesRequest, $xLineDeliveryTag, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pushMessagesByPhone'
     *
     * @param  \LINE\Clients\MessagingApi\Model\PnpMessagesRequest $pnpMessagesRequest (required)
     * @param  string $xLineDeliveryTag String returned in the delivery.data property of the delivery completion event via Webhook. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pushMessagesByPhone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function pushMessagesByPhoneRequest($pnpMessagesRequest, $xLineDeliveryTag = null, string $contentType = self::contentTypes['pushMessagesByPhone'][0])
    {

        // verify the required parameter 'pnpMessagesRequest' is set
        if ($pnpMessagesRequest === null || (is_array($pnpMessagesRequest) && count($pnpMessagesRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pnpMessagesRequest when calling pushMessagesByPhone'
            );
        }

        if ($xLineDeliveryTag !== null && strlen($xLineDeliveryTag) > 100) {
            throw new \InvalidArgumentException('invalid length for "$xLineDeliveryTag" when calling MessagingApiApi.pushMessagesByPhone, must be smaller than or equal to 100.');
        }
        if ($xLineDeliveryTag !== null && strlen($xLineDeliveryTag) < 16) {
            throw new \InvalidArgumentException('invalid length for "$xLineDeliveryTag" when calling MessagingApiApi.pushMessagesByPhone, must be bigger than or equal to 16.');
        }
        

        $resourcePath = '/bot/pnp/push';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($xLineDeliveryTag !== null) {
            $headerParams['X-Line-Delivery-Tag'] = ObjectSerializer::toHeaderValue($xLineDeliveryTag);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($pnpMessagesRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($pnpMessagesRequest));
            } else {
                $httpBody = $pnpMessagesRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replyMessage
     *
     * @param  \LINE\Clients\MessagingApi\Model\ReplyMessageRequest $replyMessageRequest replyMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replyMessage'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\ReplyMessageResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse
     */
    public function replyMessage($replyMessageRequest, string $contentType = self::contentTypes['replyMessage'][0])
    {
        list($response) = $this->replyMessageWithHttpInfo($replyMessageRequest, $contentType);
        return $response;
    }

    /**
     * Operation replyMessageWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\ReplyMessageRequest $replyMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replyMessage'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\ReplyMessageResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse|\LINE\Clients\MessagingApi\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function replyMessageWithHttpInfo($replyMessageRequest, string $contentType = self::contentTypes['replyMessage'][0])
    {
        $request = $this->replyMessageRequest($replyMessageRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\ReplyMessageResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\ReplyMessageResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\ReplyMessageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\ReplyMessageResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\ReplyMessageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replyMessageAsync
     *
     * @param  \LINE\Clients\MessagingApi\Model\ReplyMessageRequest $replyMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replyMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replyMessageAsync($replyMessageRequest, string $contentType = self::contentTypes['replyMessage'][0])
    {
        return $this->replyMessageAsyncWithHttpInfo($replyMessageRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replyMessageAsyncWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\ReplyMessageRequest $replyMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replyMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replyMessageAsyncWithHttpInfo($replyMessageRequest, string $contentType = self::contentTypes['replyMessage'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\ReplyMessageResponse';
        $request = $this->replyMessageRequest($replyMessageRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replyMessage'
     *
     * @param  \LINE\Clients\MessagingApi\Model\ReplyMessageRequest $replyMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replyMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function replyMessageRequest($replyMessageRequest, string $contentType = self::contentTypes['replyMessage'][0])
    {

        // verify the required parameter 'replyMessageRequest' is set
        if ($replyMessageRequest === null || (is_array($replyMessageRequest) && count($replyMessageRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $replyMessageRequest when calling replyMessage'
            );
        }


        $resourcePath = '/v2/bot/message/reply';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($replyMessageRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($replyMessageRequest));
            } else {
                $httpBody = $replyMessageRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation richMenuBatch
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuBatchRequest $richMenuBatchRequest richMenuBatchRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['richMenuBatch'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function richMenuBatch($richMenuBatchRequest, string $contentType = self::contentTypes['richMenuBatch'][0])
    {
        $this->richMenuBatchWithHttpInfo($richMenuBatchRequest, $contentType);
    }

    /**
     * Operation richMenuBatchWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuBatchRequest $richMenuBatchRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['richMenuBatch'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function richMenuBatchWithHttpInfo($richMenuBatchRequest, string $contentType = self::contentTypes['richMenuBatch'][0])
    {
        $request = $this->richMenuBatchRequest($richMenuBatchRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation richMenuBatchAsync
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuBatchRequest $richMenuBatchRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['richMenuBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function richMenuBatchAsync($richMenuBatchRequest, string $contentType = self::contentTypes['richMenuBatch'][0])
    {
        return $this->richMenuBatchAsyncWithHttpInfo($richMenuBatchRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation richMenuBatchAsyncWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuBatchRequest $richMenuBatchRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['richMenuBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function richMenuBatchAsyncWithHttpInfo($richMenuBatchRequest, string $contentType = self::contentTypes['richMenuBatch'][0])
    {
        $returnType = '';
        $request = $this->richMenuBatchRequest($richMenuBatchRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'richMenuBatch'
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuBatchRequest $richMenuBatchRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['richMenuBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function richMenuBatchRequest($richMenuBatchRequest, string $contentType = self::contentTypes['richMenuBatch'][0])
    {

        // verify the required parameter 'richMenuBatchRequest' is set
        if ($richMenuBatchRequest === null || (is_array($richMenuBatchRequest) && count($richMenuBatchRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $richMenuBatchRequest when calling richMenuBatch'
            );
        }


        $resourcePath = '/v2/bot/richmenu/batch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($richMenuBatchRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($richMenuBatchRequest));
            } else {
                $httpBody = $richMenuBatchRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setDefaultRichMenu
     *
     * @param  string $richMenuId ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setDefaultRichMenu'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setDefaultRichMenu($richMenuId, string $contentType = self::contentTypes['setDefaultRichMenu'][0])
    {
        $this->setDefaultRichMenuWithHttpInfo($richMenuId, $contentType);
    }

    /**
     * Operation setDefaultRichMenuWithHttpInfo
     *
     * @param  string $richMenuId ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setDefaultRichMenu'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setDefaultRichMenuWithHttpInfo($richMenuId, string $contentType = self::contentTypes['setDefaultRichMenu'][0])
    {
        $request = $this->setDefaultRichMenuRequest($richMenuId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation setDefaultRichMenuAsync
     *
     * @param  string $richMenuId ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setDefaultRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setDefaultRichMenuAsync($richMenuId, string $contentType = self::contentTypes['setDefaultRichMenu'][0])
    {
        return $this->setDefaultRichMenuAsyncWithHttpInfo($richMenuId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setDefaultRichMenuAsyncWithHttpInfo
     *
     * @param  string $richMenuId ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setDefaultRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setDefaultRichMenuAsyncWithHttpInfo($richMenuId, string $contentType = self::contentTypes['setDefaultRichMenu'][0])
    {
        $returnType = '';
        $request = $this->setDefaultRichMenuRequest($richMenuId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setDefaultRichMenu'
     *
     * @param  string $richMenuId ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setDefaultRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setDefaultRichMenuRequest($richMenuId, string $contentType = self::contentTypes['setDefaultRichMenu'][0])
    {

        // verify the required parameter 'richMenuId' is set
        if ($richMenuId === null || (is_array($richMenuId) && count($richMenuId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $richMenuId when calling setDefaultRichMenu'
            );
        }


        $resourcePath = '/v2/bot/user/all/richmenu/{richMenuId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($richMenuId !== null) {
            $resourcePath = str_replace(
                '{' . 'richMenuId' . '}',
                ObjectSerializer::toPathValue($richMenuId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setWebhookEndpoint
     *
     * @param  \LINE\Clients\MessagingApi\Model\SetWebhookEndpointRequest $setWebhookEndpointRequest setWebhookEndpointRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setWebhookEndpoint($setWebhookEndpointRequest, string $contentType = self::contentTypes['setWebhookEndpoint'][0])
    {
        $this->setWebhookEndpointWithHttpInfo($setWebhookEndpointRequest, $contentType);
    }

    /**
     * Operation setWebhookEndpointWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\SetWebhookEndpointRequest $setWebhookEndpointRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setWebhookEndpointWithHttpInfo($setWebhookEndpointRequest, string $contentType = self::contentTypes['setWebhookEndpoint'][0])
    {
        $request = $this->setWebhookEndpointRequest($setWebhookEndpointRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation setWebhookEndpointAsync
     *
     * @param  \LINE\Clients\MessagingApi\Model\SetWebhookEndpointRequest $setWebhookEndpointRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setWebhookEndpointAsync($setWebhookEndpointRequest, string $contentType = self::contentTypes['setWebhookEndpoint'][0])
    {
        return $this->setWebhookEndpointAsyncWithHttpInfo($setWebhookEndpointRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setWebhookEndpointAsyncWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\SetWebhookEndpointRequest $setWebhookEndpointRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setWebhookEndpointAsyncWithHttpInfo($setWebhookEndpointRequest, string $contentType = self::contentTypes['setWebhookEndpoint'][0])
    {
        $returnType = '';
        $request = $this->setWebhookEndpointRequest($setWebhookEndpointRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setWebhookEndpoint'
     *
     * @param  \LINE\Clients\MessagingApi\Model\SetWebhookEndpointRequest $setWebhookEndpointRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setWebhookEndpointRequest($setWebhookEndpointRequest, string $contentType = self::contentTypes['setWebhookEndpoint'][0])
    {

        // verify the required parameter 'setWebhookEndpointRequest' is set
        if ($setWebhookEndpointRequest === null || (is_array($setWebhookEndpointRequest) && count($setWebhookEndpointRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $setWebhookEndpointRequest when calling setWebhookEndpoint'
            );
        }


        $resourcePath = '/v2/bot/channel/webhook/endpoint';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($setWebhookEndpointRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($setWebhookEndpointRequest));
            } else {
                $httpBody = $setWebhookEndpointRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation testWebhookEndpoint
     *
     * @param  \LINE\Clients\MessagingApi\Model\TestWebhookEndpointRequest $testWebhookEndpointRequest testWebhookEndpointRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LINE\Clients\MessagingApi\Model\TestWebhookEndpointResponse
     */
    public function testWebhookEndpoint($testWebhookEndpointRequest = null, string $contentType = self::contentTypes['testWebhookEndpoint'][0])
    {
        list($response) = $this->testWebhookEndpointWithHttpInfo($testWebhookEndpointRequest, $contentType);
        return $response;
    }

    /**
     * Operation testWebhookEndpointWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\TestWebhookEndpointRequest $testWebhookEndpointRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LINE\Clients\MessagingApi\Model\TestWebhookEndpointResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function testWebhookEndpointWithHttpInfo($testWebhookEndpointRequest = null, string $contentType = self::contentTypes['testWebhookEndpoint'][0])
    {
        $request = $this->testWebhookEndpointRequest($testWebhookEndpointRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LINE\Clients\MessagingApi\Model\TestWebhookEndpointResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LINE\Clients\MessagingApi\Model\TestWebhookEndpointResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LINE\Clients\MessagingApi\Model\TestWebhookEndpointResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LINE\Clients\MessagingApi\Model\TestWebhookEndpointResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\TestWebhookEndpointResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation testWebhookEndpointAsync
     *
     * @param  \LINE\Clients\MessagingApi\Model\TestWebhookEndpointRequest $testWebhookEndpointRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function testWebhookEndpointAsync($testWebhookEndpointRequest = null, string $contentType = self::contentTypes['testWebhookEndpoint'][0])
    {
        return $this->testWebhookEndpointAsyncWithHttpInfo($testWebhookEndpointRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation testWebhookEndpointAsyncWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\TestWebhookEndpointRequest $testWebhookEndpointRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function testWebhookEndpointAsyncWithHttpInfo($testWebhookEndpointRequest = null, string $contentType = self::contentTypes['testWebhookEndpoint'][0])
    {
        $returnType = '\LINE\Clients\MessagingApi\Model\TestWebhookEndpointResponse';
        $request = $this->testWebhookEndpointRequest($testWebhookEndpointRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'testWebhookEndpoint'
     *
     * @param  \LINE\Clients\MessagingApi\Model\TestWebhookEndpointRequest $testWebhookEndpointRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function testWebhookEndpointRequest($testWebhookEndpointRequest = null, string $contentType = self::contentTypes['testWebhookEndpoint'][0])
    {



        $resourcePath = '/v2/bot/channel/webhook/test';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($testWebhookEndpointRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($testWebhookEndpointRequest));
            } else {
                $httpBody = $testWebhookEndpointRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unlinkRichMenuIdFromUser
     *
     * @param  string $userId User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkRichMenuIdFromUser'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function unlinkRichMenuIdFromUser($userId, string $contentType = self::contentTypes['unlinkRichMenuIdFromUser'][0])
    {
        $this->unlinkRichMenuIdFromUserWithHttpInfo($userId, $contentType);
    }

    /**
     * Operation unlinkRichMenuIdFromUserWithHttpInfo
     *
     * @param  string $userId User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkRichMenuIdFromUser'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function unlinkRichMenuIdFromUserWithHttpInfo($userId, string $contentType = self::contentTypes['unlinkRichMenuIdFromUser'][0])
    {
        $request = $this->unlinkRichMenuIdFromUserRequest($userId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation unlinkRichMenuIdFromUserAsync
     *
     * @param  string $userId User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkRichMenuIdFromUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unlinkRichMenuIdFromUserAsync($userId, string $contentType = self::contentTypes['unlinkRichMenuIdFromUser'][0])
    {
        return $this->unlinkRichMenuIdFromUserAsyncWithHttpInfo($userId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unlinkRichMenuIdFromUserAsyncWithHttpInfo
     *
     * @param  string $userId User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkRichMenuIdFromUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unlinkRichMenuIdFromUserAsyncWithHttpInfo($userId, string $contentType = self::contentTypes['unlinkRichMenuIdFromUser'][0])
    {
        $returnType = '';
        $request = $this->unlinkRichMenuIdFromUserRequest($userId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unlinkRichMenuIdFromUser'
     *
     * @param  string $userId User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkRichMenuIdFromUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unlinkRichMenuIdFromUserRequest($userId, string $contentType = self::contentTypes['unlinkRichMenuIdFromUser'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling unlinkRichMenuIdFromUser'
            );
        }


        $resourcePath = '/v2/bot/user/{userId}/richmenu';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unlinkRichMenuIdFromUsers
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuBulkUnlinkRequest $richMenuBulkUnlinkRequest richMenuBulkUnlinkRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkRichMenuIdFromUsers'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function unlinkRichMenuIdFromUsers($richMenuBulkUnlinkRequest, string $contentType = self::contentTypes['unlinkRichMenuIdFromUsers'][0])
    {
        $this->unlinkRichMenuIdFromUsersWithHttpInfo($richMenuBulkUnlinkRequest, $contentType);
    }

    /**
     * Operation unlinkRichMenuIdFromUsersWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuBulkUnlinkRequest $richMenuBulkUnlinkRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkRichMenuIdFromUsers'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function unlinkRichMenuIdFromUsersWithHttpInfo($richMenuBulkUnlinkRequest, string $contentType = self::contentTypes['unlinkRichMenuIdFromUsers'][0])
    {
        $request = $this->unlinkRichMenuIdFromUsersRequest($richMenuBulkUnlinkRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation unlinkRichMenuIdFromUsersAsync
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuBulkUnlinkRequest $richMenuBulkUnlinkRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkRichMenuIdFromUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unlinkRichMenuIdFromUsersAsync($richMenuBulkUnlinkRequest, string $contentType = self::contentTypes['unlinkRichMenuIdFromUsers'][0])
    {
        return $this->unlinkRichMenuIdFromUsersAsyncWithHttpInfo($richMenuBulkUnlinkRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unlinkRichMenuIdFromUsersAsyncWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuBulkUnlinkRequest $richMenuBulkUnlinkRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkRichMenuIdFromUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unlinkRichMenuIdFromUsersAsyncWithHttpInfo($richMenuBulkUnlinkRequest, string $contentType = self::contentTypes['unlinkRichMenuIdFromUsers'][0])
    {
        $returnType = '';
        $request = $this->unlinkRichMenuIdFromUsersRequest($richMenuBulkUnlinkRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unlinkRichMenuIdFromUsers'
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuBulkUnlinkRequest $richMenuBulkUnlinkRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkRichMenuIdFromUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unlinkRichMenuIdFromUsersRequest($richMenuBulkUnlinkRequest, string $contentType = self::contentTypes['unlinkRichMenuIdFromUsers'][0])
    {

        // verify the required parameter 'richMenuBulkUnlinkRequest' is set
        if ($richMenuBulkUnlinkRequest === null || (is_array($richMenuBulkUnlinkRequest) && count($richMenuBulkUnlinkRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $richMenuBulkUnlinkRequest when calling unlinkRichMenuIdFromUsers'
            );
        }


        $resourcePath = '/v2/bot/richmenu/bulk/unlink';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($richMenuBulkUnlinkRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($richMenuBulkUnlinkRequest));
            } else {
                $httpBody = $richMenuBulkUnlinkRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateRichMenuAlias
     *
     * @param  string $richMenuAliasId The rich menu alias ID you want to update. (required)
     * @param  \LINE\Clients\MessagingApi\Model\UpdateRichMenuAliasRequest $updateRichMenuAliasRequest updateRichMenuAliasRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateRichMenuAlias($richMenuAliasId, $updateRichMenuAliasRequest, string $contentType = self::contentTypes['updateRichMenuAlias'][0])
    {
        $this->updateRichMenuAliasWithHttpInfo($richMenuAliasId, $updateRichMenuAliasRequest, $contentType);
    }

    /**
     * Operation updateRichMenuAliasWithHttpInfo
     *
     * @param  string $richMenuAliasId The rich menu alias ID you want to update. (required)
     * @param  \LINE\Clients\MessagingApi\Model\UpdateRichMenuAliasRequest $updateRichMenuAliasRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateRichMenuAliasWithHttpInfo($richMenuAliasId, $updateRichMenuAliasRequest, string $contentType = self::contentTypes['updateRichMenuAlias'][0])
    {
        $request = $this->updateRichMenuAliasRequest($richMenuAliasId, $updateRichMenuAliasRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LINE\Clients\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateRichMenuAliasAsync
     *
     * @param  string $richMenuAliasId The rich menu alias ID you want to update. (required)
     * @param  \LINE\Clients\MessagingApi\Model\UpdateRichMenuAliasRequest $updateRichMenuAliasRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateRichMenuAliasAsync($richMenuAliasId, $updateRichMenuAliasRequest, string $contentType = self::contentTypes['updateRichMenuAlias'][0])
    {
        return $this->updateRichMenuAliasAsyncWithHttpInfo($richMenuAliasId, $updateRichMenuAliasRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateRichMenuAliasAsyncWithHttpInfo
     *
     * @param  string $richMenuAliasId The rich menu alias ID you want to update. (required)
     * @param  \LINE\Clients\MessagingApi\Model\UpdateRichMenuAliasRequest $updateRichMenuAliasRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateRichMenuAliasAsyncWithHttpInfo($richMenuAliasId, $updateRichMenuAliasRequest, string $contentType = self::contentTypes['updateRichMenuAlias'][0])
    {
        $returnType = '';
        $request = $this->updateRichMenuAliasRequest($richMenuAliasId, $updateRichMenuAliasRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateRichMenuAlias'
     *
     * @param  string $richMenuAliasId The rich menu alias ID you want to update. (required)
     * @param  \LINE\Clients\MessagingApi\Model\UpdateRichMenuAliasRequest $updateRichMenuAliasRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateRichMenuAliasRequest($richMenuAliasId, $updateRichMenuAliasRequest, string $contentType = self::contentTypes['updateRichMenuAlias'][0])
    {

        // verify the required parameter 'richMenuAliasId' is set
        if ($richMenuAliasId === null || (is_array($richMenuAliasId) && count($richMenuAliasId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $richMenuAliasId when calling updateRichMenuAlias'
            );
        }

        // verify the required parameter 'updateRichMenuAliasRequest' is set
        if ($updateRichMenuAliasRequest === null || (is_array($updateRichMenuAliasRequest) && count($updateRichMenuAliasRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateRichMenuAliasRequest when calling updateRichMenuAlias'
            );
        }


        $resourcePath = '/v2/bot/richmenu/alias/{richMenuAliasId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($richMenuAliasId !== null) {
            $resourcePath = str_replace(
                '{' . 'richMenuAliasId' . '}',
                ObjectSerializer::toPathValue($richMenuAliasId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateRichMenuAliasRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateRichMenuAliasRequest));
            } else {
                $httpBody = $updateRichMenuAliasRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation validateBroadcast
     *
     * @param  \LINE\Clients\MessagingApi\Model\ValidateMessageRequest $validateMessageRequest validateMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateBroadcast'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function validateBroadcast($validateMessageRequest, string $contentType = self::contentTypes['validateBroadcast'][0])
    {
        $this->validateBroadcastWithHttpInfo($validateMessageRequest, $contentType);
    }

    /**
     * Operation validateBroadcastWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\ValidateMessageRequest $validateMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateBroadcast'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function validateBroadcastWithHttpInfo($validateMessageRequest, string $contentType = self::contentTypes['validateBroadcast'][0])
    {
        $request = $this->validateBroadcastRequest($validateMessageRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation validateBroadcastAsync
     *
     * @param  \LINE\Clients\MessagingApi\Model\ValidateMessageRequest $validateMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateBroadcast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateBroadcastAsync($validateMessageRequest, string $contentType = self::contentTypes['validateBroadcast'][0])
    {
        return $this->validateBroadcastAsyncWithHttpInfo($validateMessageRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation validateBroadcastAsyncWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\ValidateMessageRequest $validateMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateBroadcast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateBroadcastAsyncWithHttpInfo($validateMessageRequest, string $contentType = self::contentTypes['validateBroadcast'][0])
    {
        $returnType = '';
        $request = $this->validateBroadcastRequest($validateMessageRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'validateBroadcast'
     *
     * @param  \LINE\Clients\MessagingApi\Model\ValidateMessageRequest $validateMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateBroadcast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function validateBroadcastRequest($validateMessageRequest, string $contentType = self::contentTypes['validateBroadcast'][0])
    {

        // verify the required parameter 'validateMessageRequest' is set
        if ($validateMessageRequest === null || (is_array($validateMessageRequest) && count($validateMessageRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $validateMessageRequest when calling validateBroadcast'
            );
        }


        $resourcePath = '/v2/bot/message/validate/broadcast';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($validateMessageRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($validateMessageRequest));
            } else {
                $httpBody = $validateMessageRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation validateMulticast
     *
     * @param  \LINE\Clients\MessagingApi\Model\ValidateMessageRequest $validateMessageRequest validateMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateMulticast'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function validateMulticast($validateMessageRequest, string $contentType = self::contentTypes['validateMulticast'][0])
    {
        $this->validateMulticastWithHttpInfo($validateMessageRequest, $contentType);
    }

    /**
     * Operation validateMulticastWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\ValidateMessageRequest $validateMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateMulticast'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function validateMulticastWithHttpInfo($validateMessageRequest, string $contentType = self::contentTypes['validateMulticast'][0])
    {
        $request = $this->validateMulticastRequest($validateMessageRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation validateMulticastAsync
     *
     * @param  \LINE\Clients\MessagingApi\Model\ValidateMessageRequest $validateMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateMulticast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateMulticastAsync($validateMessageRequest, string $contentType = self::contentTypes['validateMulticast'][0])
    {
        return $this->validateMulticastAsyncWithHttpInfo($validateMessageRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation validateMulticastAsyncWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\ValidateMessageRequest $validateMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateMulticast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateMulticastAsyncWithHttpInfo($validateMessageRequest, string $contentType = self::contentTypes['validateMulticast'][0])
    {
        $returnType = '';
        $request = $this->validateMulticastRequest($validateMessageRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'validateMulticast'
     *
     * @param  \LINE\Clients\MessagingApi\Model\ValidateMessageRequest $validateMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateMulticast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function validateMulticastRequest($validateMessageRequest, string $contentType = self::contentTypes['validateMulticast'][0])
    {

        // verify the required parameter 'validateMessageRequest' is set
        if ($validateMessageRequest === null || (is_array($validateMessageRequest) && count($validateMessageRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $validateMessageRequest when calling validateMulticast'
            );
        }


        $resourcePath = '/v2/bot/message/validate/multicast';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($validateMessageRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($validateMessageRequest));
            } else {
                $httpBody = $validateMessageRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation validateNarrowcast
     *
     * @param  \LINE\Clients\MessagingApi\Model\ValidateMessageRequest $validateMessageRequest validateMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateNarrowcast'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function validateNarrowcast($validateMessageRequest, string $contentType = self::contentTypes['validateNarrowcast'][0])
    {
        $this->validateNarrowcastWithHttpInfo($validateMessageRequest, $contentType);
    }

    /**
     * Operation validateNarrowcastWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\ValidateMessageRequest $validateMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateNarrowcast'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function validateNarrowcastWithHttpInfo($validateMessageRequest, string $contentType = self::contentTypes['validateNarrowcast'][0])
    {
        $request = $this->validateNarrowcastRequest($validateMessageRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation validateNarrowcastAsync
     *
     * @param  \LINE\Clients\MessagingApi\Model\ValidateMessageRequest $validateMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateNarrowcast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateNarrowcastAsync($validateMessageRequest, string $contentType = self::contentTypes['validateNarrowcast'][0])
    {
        return $this->validateNarrowcastAsyncWithHttpInfo($validateMessageRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation validateNarrowcastAsyncWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\ValidateMessageRequest $validateMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateNarrowcast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateNarrowcastAsyncWithHttpInfo($validateMessageRequest, string $contentType = self::contentTypes['validateNarrowcast'][0])
    {
        $returnType = '';
        $request = $this->validateNarrowcastRequest($validateMessageRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'validateNarrowcast'
     *
     * @param  \LINE\Clients\MessagingApi\Model\ValidateMessageRequest $validateMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateNarrowcast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function validateNarrowcastRequest($validateMessageRequest, string $contentType = self::contentTypes['validateNarrowcast'][0])
    {

        // verify the required parameter 'validateMessageRequest' is set
        if ($validateMessageRequest === null || (is_array($validateMessageRequest) && count($validateMessageRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $validateMessageRequest when calling validateNarrowcast'
            );
        }


        $resourcePath = '/v2/bot/message/validate/narrowcast';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($validateMessageRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($validateMessageRequest));
            } else {
                $httpBody = $validateMessageRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation validatePush
     *
     * @param  \LINE\Clients\MessagingApi\Model\ValidateMessageRequest $validateMessageRequest validateMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validatePush'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function validatePush($validateMessageRequest, string $contentType = self::contentTypes['validatePush'][0])
    {
        $this->validatePushWithHttpInfo($validateMessageRequest, $contentType);
    }

    /**
     * Operation validatePushWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\ValidateMessageRequest $validateMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validatePush'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function validatePushWithHttpInfo($validateMessageRequest, string $contentType = self::contentTypes['validatePush'][0])
    {
        $request = $this->validatePushRequest($validateMessageRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation validatePushAsync
     *
     * @param  \LINE\Clients\MessagingApi\Model\ValidateMessageRequest $validateMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validatePush'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validatePushAsync($validateMessageRequest, string $contentType = self::contentTypes['validatePush'][0])
    {
        return $this->validatePushAsyncWithHttpInfo($validateMessageRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation validatePushAsyncWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\ValidateMessageRequest $validateMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validatePush'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validatePushAsyncWithHttpInfo($validateMessageRequest, string $contentType = self::contentTypes['validatePush'][0])
    {
        $returnType = '';
        $request = $this->validatePushRequest($validateMessageRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'validatePush'
     *
     * @param  \LINE\Clients\MessagingApi\Model\ValidateMessageRequest $validateMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validatePush'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function validatePushRequest($validateMessageRequest, string $contentType = self::contentTypes['validatePush'][0])
    {

        // verify the required parameter 'validateMessageRequest' is set
        if ($validateMessageRequest === null || (is_array($validateMessageRequest) && count($validateMessageRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $validateMessageRequest when calling validatePush'
            );
        }


        $resourcePath = '/v2/bot/message/validate/push';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($validateMessageRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($validateMessageRequest));
            } else {
                $httpBody = $validateMessageRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation validateReply
     *
     * @param  \LINE\Clients\MessagingApi\Model\ValidateMessageRequest $validateMessageRequest validateMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateReply'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function validateReply($validateMessageRequest, string $contentType = self::contentTypes['validateReply'][0])
    {
        $this->validateReplyWithHttpInfo($validateMessageRequest, $contentType);
    }

    /**
     * Operation validateReplyWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\ValidateMessageRequest $validateMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateReply'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function validateReplyWithHttpInfo($validateMessageRequest, string $contentType = self::contentTypes['validateReply'][0])
    {
        $request = $this->validateReplyRequest($validateMessageRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation validateReplyAsync
     *
     * @param  \LINE\Clients\MessagingApi\Model\ValidateMessageRequest $validateMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateReply'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateReplyAsync($validateMessageRequest, string $contentType = self::contentTypes['validateReply'][0])
    {
        return $this->validateReplyAsyncWithHttpInfo($validateMessageRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation validateReplyAsyncWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\ValidateMessageRequest $validateMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateReply'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateReplyAsyncWithHttpInfo($validateMessageRequest, string $contentType = self::contentTypes['validateReply'][0])
    {
        $returnType = '';
        $request = $this->validateReplyRequest($validateMessageRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'validateReply'
     *
     * @param  \LINE\Clients\MessagingApi\Model\ValidateMessageRequest $validateMessageRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateReply'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function validateReplyRequest($validateMessageRequest, string $contentType = self::contentTypes['validateReply'][0])
    {

        // verify the required parameter 'validateMessageRequest' is set
        if ($validateMessageRequest === null || (is_array($validateMessageRequest) && count($validateMessageRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $validateMessageRequest when calling validateReply'
            );
        }


        $resourcePath = '/v2/bot/message/validate/reply';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($validateMessageRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($validateMessageRequest));
            } else {
                $httpBody = $validateMessageRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation validateRichMenuBatchRequest
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuBatchRequest $richMenuBatchRequest richMenuBatchRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateRichMenuBatchRequest'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function validateRichMenuBatchRequest($richMenuBatchRequest, string $contentType = self::contentTypes['validateRichMenuBatchRequest'][0])
    {
        $this->validateRichMenuBatchRequestWithHttpInfo($richMenuBatchRequest, $contentType);
    }

    /**
     * Operation validateRichMenuBatchRequestWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuBatchRequest $richMenuBatchRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateRichMenuBatchRequest'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function validateRichMenuBatchRequestWithHttpInfo($richMenuBatchRequest, string $contentType = self::contentTypes['validateRichMenuBatchRequest'][0])
    {
        $request = $this->validateRichMenuBatchRequestRequest($richMenuBatchRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation validateRichMenuBatchRequestAsync
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuBatchRequest $richMenuBatchRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateRichMenuBatchRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateRichMenuBatchRequestAsync($richMenuBatchRequest, string $contentType = self::contentTypes['validateRichMenuBatchRequest'][0])
    {
        return $this->validateRichMenuBatchRequestAsyncWithHttpInfo($richMenuBatchRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation validateRichMenuBatchRequestAsyncWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuBatchRequest $richMenuBatchRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateRichMenuBatchRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateRichMenuBatchRequestAsyncWithHttpInfo($richMenuBatchRequest, string $contentType = self::contentTypes['validateRichMenuBatchRequest'][0])
    {
        $returnType = '';
        $request = $this->validateRichMenuBatchRequestRequest($richMenuBatchRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'validateRichMenuBatchRequest'
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuBatchRequest $richMenuBatchRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateRichMenuBatchRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function validateRichMenuBatchRequestRequest($richMenuBatchRequest, string $contentType = self::contentTypes['validateRichMenuBatchRequest'][0])
    {

        // verify the required parameter 'richMenuBatchRequest' is set
        if ($richMenuBatchRequest === null || (is_array($richMenuBatchRequest) && count($richMenuBatchRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $richMenuBatchRequest when calling validateRichMenuBatchRequest'
            );
        }


        $resourcePath = '/v2/bot/richmenu/validate/batch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($richMenuBatchRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($richMenuBatchRequest));
            } else {
                $httpBody = $richMenuBatchRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation validateRichMenuObject
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuRequest $richMenuRequest richMenuRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateRichMenuObject'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function validateRichMenuObject($richMenuRequest, string $contentType = self::contentTypes['validateRichMenuObject'][0])
    {
        $this->validateRichMenuObjectWithHttpInfo($richMenuRequest, $contentType);
    }

    /**
     * Operation validateRichMenuObjectWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuRequest $richMenuRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateRichMenuObject'] to see the possible values for this operation
     *
     * @throws \LINE\Clients\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function validateRichMenuObjectWithHttpInfo($richMenuRequest, string $contentType = self::contentTypes['validateRichMenuObject'][0])
    {
        $request = $this->validateRichMenuObjectRequest($richMenuRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation validateRichMenuObjectAsync
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuRequest $richMenuRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateRichMenuObject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateRichMenuObjectAsync($richMenuRequest, string $contentType = self::contentTypes['validateRichMenuObject'][0])
    {
        return $this->validateRichMenuObjectAsyncWithHttpInfo($richMenuRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation validateRichMenuObjectAsyncWithHttpInfo
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuRequest $richMenuRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateRichMenuObject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateRichMenuObjectAsyncWithHttpInfo($richMenuRequest, string $contentType = self::contentTypes['validateRichMenuObject'][0])
    {
        $returnType = '';
        $request = $this->validateRichMenuObjectRequest($richMenuRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'validateRichMenuObject'
     *
     * @param  \LINE\Clients\MessagingApi\Model\RichMenuRequest $richMenuRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateRichMenuObject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function validateRichMenuObjectRequest($richMenuRequest, string $contentType = self::contentTypes['validateRichMenuObject'][0])
    {

        // verify the required parameter 'richMenuRequest' is set
        if ($richMenuRequest === null || (is_array($richMenuRequest) && count($richMenuRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $richMenuRequest when calling validateRichMenuObject'
            );
        }


        $resourcePath = '/v2/bot/richmenu/validate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($richMenuRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($richMenuRequest));
            } else {
                $httpBody = $richMenuRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
